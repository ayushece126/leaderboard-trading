// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: service/trade.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "trade";

export interface TradeConfig {
  priorityFee: bigint;
  maxSlippageBps: number;
  mevProtectEnabled: boolean;
  tip: bigint;
}

export interface TradeConfigPreset {
  name: string;
  buyConfig: TradeConfig | undefined;
  sellConfig: TradeConfig | undefined;
}

export interface SpotBuyRequest {
  asset?: string | undefined;
  fromPubKey: string;
  quoteAmount: bigint;
  configPresetName: string;
  password: string;
}

export interface SpotBuyResponse {
  signature: string;
}

export interface SpotSellRequest {
  asset?: string | undefined;
  fromPubKey: string;
  baseAmount?: bigint | undefined;
  baseAmountBps?: number | undefined;
  configPresetName: string;
  password: string;
}

export interface SpotSellResponse {
  signature: string;
}

export interface GetTradeConfigPresetsRequest {
}

export interface GetTradeConfigPresetsResponse {
  presets: TradeConfigPreset[];
}

export interface SetTradeConfigPresetRequest {
  preset: TradeConfigPreset | undefined;
}

export interface SetTradeConfigPresetResponse {
  success: boolean;
}

function createBaseTradeConfig(): TradeConfig {
  return { priorityFee: 0n, maxSlippageBps: 0, mevProtectEnabled: false, tip: 0n };
}

export const TradeConfig: MessageFns<TradeConfig> = {
  encode(message: TradeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priorityFee !== 0n) {
      if (BigInt.asUintN(64, message.priorityFee) !== message.priorityFee) {
        throw new globalThis.Error("value provided for field message.priorityFee of type uint64 too large");
      }
      writer.uint32(8).uint64(message.priorityFee);
    }
    if (message.maxSlippageBps !== 0) {
      writer.uint32(21).float(message.maxSlippageBps);
    }
    if (message.mevProtectEnabled !== false) {
      writer.uint32(24).bool(message.mevProtectEnabled);
    }
    if (message.tip !== 0n) {
      if (BigInt.asUintN(64, message.tip) !== message.tip) {
        throw new globalThis.Error("value provided for field message.tip of type uint64 too large");
      }
      writer.uint32(32).uint64(message.tip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TradeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.priorityFee = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.maxSlippageBps = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mevProtectEnabled = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tip = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeConfig {
    return {
      priorityFee: isSet(object.priorityFee) ? BigInt(object.priorityFee) : 0n,
      maxSlippageBps: isSet(object.maxSlippageBps) ? globalThis.Number(object.maxSlippageBps) : 0,
      mevProtectEnabled: isSet(object.mevProtectEnabled) ? globalThis.Boolean(object.mevProtectEnabled) : false,
      tip: isSet(object.tip) ? BigInt(object.tip) : 0n,
    };
  },

  toJSON(message: TradeConfig): unknown {
    const obj: any = {};
    if (message.priorityFee !== 0n) {
      obj.priorityFee = message.priorityFee.toString();
    }
    if (message.maxSlippageBps !== 0) {
      obj.maxSlippageBps = message.maxSlippageBps;
    }
    if (message.mevProtectEnabled !== false) {
      obj.mevProtectEnabled = message.mevProtectEnabled;
    }
    if (message.tip !== 0n) {
      obj.tip = message.tip.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeConfig>, I>>(base?: I): TradeConfig {
    return TradeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeConfig>, I>>(object: I): TradeConfig {
    const message = createBaseTradeConfig();
    message.priorityFee = object.priorityFee ?? 0n;
    message.maxSlippageBps = object.maxSlippageBps ?? 0;
    message.mevProtectEnabled = object.mevProtectEnabled ?? false;
    message.tip = object.tip ?? 0n;
    return message;
  },
};

function createBaseTradeConfigPreset(): TradeConfigPreset {
  return { name: "", buyConfig: undefined, sellConfig: undefined };
}

export const TradeConfigPreset: MessageFns<TradeConfigPreset> = {
  encode(message: TradeConfigPreset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.buyConfig !== undefined) {
      TradeConfig.encode(message.buyConfig, writer.uint32(18).fork()).join();
    }
    if (message.sellConfig !== undefined) {
      TradeConfig.encode(message.sellConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TradeConfigPreset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeConfigPreset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buyConfig = TradeConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sellConfig = TradeConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeConfigPreset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      buyConfig: isSet(object.buyConfig) ? TradeConfig.fromJSON(object.buyConfig) : undefined,
      sellConfig: isSet(object.sellConfig) ? TradeConfig.fromJSON(object.sellConfig) : undefined,
    };
  },

  toJSON(message: TradeConfigPreset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.buyConfig !== undefined) {
      obj.buyConfig = TradeConfig.toJSON(message.buyConfig);
    }
    if (message.sellConfig !== undefined) {
      obj.sellConfig = TradeConfig.toJSON(message.sellConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeConfigPreset>, I>>(base?: I): TradeConfigPreset {
    return TradeConfigPreset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeConfigPreset>, I>>(object: I): TradeConfigPreset {
    const message = createBaseTradeConfigPreset();
    message.name = object.name ?? "";
    message.buyConfig = (object.buyConfig !== undefined && object.buyConfig !== null)
      ? TradeConfig.fromPartial(object.buyConfig)
      : undefined;
    message.sellConfig = (object.sellConfig !== undefined && object.sellConfig !== null)
      ? TradeConfig.fromPartial(object.sellConfig)
      : undefined;
    return message;
  },
};

function createBaseSpotBuyRequest(): SpotBuyRequest {
  return { asset: undefined, fromPubKey: "", quoteAmount: 0n, configPresetName: "", password: "" };
}

export const SpotBuyRequest: MessageFns<SpotBuyRequest> = {
  encode(message: SpotBuyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== undefined) {
      writer.uint32(10).string(message.asset);
    }
    if (message.fromPubKey !== "") {
      writer.uint32(18).string(message.fromPubKey);
    }
    if (message.quoteAmount !== 0n) {
      if (BigInt.asUintN(64, message.quoteAmount) !== message.quoteAmount) {
        throw new globalThis.Error("value provided for field message.quoteAmount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.quoteAmount);
    }
    if (message.configPresetName !== "") {
      writer.uint32(34).string(message.configPresetName);
    }
    if (message.password !== "") {
      writer.uint32(42).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpotBuyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotBuyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromPubKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quoteAmount = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.configPresetName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpotBuyRequest {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : undefined,
      fromPubKey: isSet(object.fromPubKey) ? globalThis.String(object.fromPubKey) : "",
      quoteAmount: isSet(object.quoteAmount) ? BigInt(object.quoteAmount) : 0n,
      configPresetName: isSet(object.configPresetName) ? globalThis.String(object.configPresetName) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: SpotBuyRequest): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = message.asset;
    }
    if (message.fromPubKey !== "") {
      obj.fromPubKey = message.fromPubKey;
    }
    if (message.quoteAmount !== 0n) {
      obj.quoteAmount = message.quoteAmount.toString();
    }
    if (message.configPresetName !== "") {
      obj.configPresetName = message.configPresetName;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpotBuyRequest>, I>>(base?: I): SpotBuyRequest {
    return SpotBuyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpotBuyRequest>, I>>(object: I): SpotBuyRequest {
    const message = createBaseSpotBuyRequest();
    message.asset = object.asset ?? undefined;
    message.fromPubKey = object.fromPubKey ?? "";
    message.quoteAmount = object.quoteAmount ?? 0n;
    message.configPresetName = object.configPresetName ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseSpotBuyResponse(): SpotBuyResponse {
  return { signature: "" };
}

export const SpotBuyResponse: MessageFns<SpotBuyResponse> = {
  encode(message: SpotBuyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpotBuyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotBuyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpotBuyResponse {
    return { signature: isSet(object.signature) ? globalThis.String(object.signature) : "" };
  },

  toJSON(message: SpotBuyResponse): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpotBuyResponse>, I>>(base?: I): SpotBuyResponse {
    return SpotBuyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpotBuyResponse>, I>>(object: I): SpotBuyResponse {
    const message = createBaseSpotBuyResponse();
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseSpotSellRequest(): SpotSellRequest {
  return {
    asset: undefined,
    fromPubKey: "",
    baseAmount: undefined,
    baseAmountBps: undefined,
    configPresetName: "",
    password: "",
  };
}

export const SpotSellRequest: MessageFns<SpotSellRequest> = {
  encode(message: SpotSellRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== undefined) {
      writer.uint32(10).string(message.asset);
    }
    if (message.fromPubKey !== "") {
      writer.uint32(18).string(message.fromPubKey);
    }
    if (message.baseAmount !== undefined) {
      if (BigInt.asUintN(64, message.baseAmount) !== message.baseAmount) {
        throw new globalThis.Error("value provided for field message.baseAmount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.baseAmount);
    }
    if (message.baseAmountBps !== undefined) {
      writer.uint32(37).float(message.baseAmountBps);
    }
    if (message.configPresetName !== "") {
      writer.uint32(42).string(message.configPresetName);
    }
    if (message.password !== "") {
      writer.uint32(50).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpotSellRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotSellRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromPubKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.baseAmount = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.baseAmountBps = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.configPresetName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpotSellRequest {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : undefined,
      fromPubKey: isSet(object.fromPubKey) ? globalThis.String(object.fromPubKey) : "",
      baseAmount: isSet(object.baseAmount) ? BigInt(object.baseAmount) : undefined,
      baseAmountBps: isSet(object.baseAmountBps) ? globalThis.Number(object.baseAmountBps) : undefined,
      configPresetName: isSet(object.configPresetName) ? globalThis.String(object.configPresetName) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: SpotSellRequest): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = message.asset;
    }
    if (message.fromPubKey !== "") {
      obj.fromPubKey = message.fromPubKey;
    }
    if (message.baseAmount !== undefined) {
      obj.baseAmount = message.baseAmount.toString();
    }
    if (message.baseAmountBps !== undefined) {
      obj.baseAmountBps = message.baseAmountBps;
    }
    if (message.configPresetName !== "") {
      obj.configPresetName = message.configPresetName;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpotSellRequest>, I>>(base?: I): SpotSellRequest {
    return SpotSellRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpotSellRequest>, I>>(object: I): SpotSellRequest {
    const message = createBaseSpotSellRequest();
    message.asset = object.asset ?? undefined;
    message.fromPubKey = object.fromPubKey ?? "";
    message.baseAmount = object.baseAmount ?? undefined;
    message.baseAmountBps = object.baseAmountBps ?? undefined;
    message.configPresetName = object.configPresetName ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseSpotSellResponse(): SpotSellResponse {
  return { signature: "" };
}

export const SpotSellResponse: MessageFns<SpotSellResponse> = {
  encode(message: SpotSellResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpotSellResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpotSellResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpotSellResponse {
    return { signature: isSet(object.signature) ? globalThis.String(object.signature) : "" };
  },

  toJSON(message: SpotSellResponse): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpotSellResponse>, I>>(base?: I): SpotSellResponse {
    return SpotSellResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpotSellResponse>, I>>(object: I): SpotSellResponse {
    const message = createBaseSpotSellResponse();
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseGetTradeConfigPresetsRequest(): GetTradeConfigPresetsRequest {
  return {};
}

export const GetTradeConfigPresetsRequest: MessageFns<GetTradeConfigPresetsRequest> = {
  encode(_: GetTradeConfigPresetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradeConfigPresetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradeConfigPresetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTradeConfigPresetsRequest {
    return {};
  },

  toJSON(_: GetTradeConfigPresetsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradeConfigPresetsRequest>, I>>(base?: I): GetTradeConfigPresetsRequest {
    return GetTradeConfigPresetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradeConfigPresetsRequest>, I>>(_: I): GetTradeConfigPresetsRequest {
    const message = createBaseGetTradeConfigPresetsRequest();
    return message;
  },
};

function createBaseGetTradeConfigPresetsResponse(): GetTradeConfigPresetsResponse {
  return { presets: [] };
}

export const GetTradeConfigPresetsResponse: MessageFns<GetTradeConfigPresetsResponse> = {
  encode(message: GetTradeConfigPresetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.presets) {
      TradeConfigPreset.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradeConfigPresetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradeConfigPresetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.presets.push(TradeConfigPreset.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTradeConfigPresetsResponse {
    return {
      presets: globalThis.Array.isArray(object?.presets)
        ? object.presets.map((e: any) => TradeConfigPreset.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTradeConfigPresetsResponse): unknown {
    const obj: any = {};
    if (message.presets?.length) {
      obj.presets = message.presets.map((e) => TradeConfigPreset.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTradeConfigPresetsResponse>, I>>(base?: I): GetTradeConfigPresetsResponse {
    return GetTradeConfigPresetsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTradeConfigPresetsResponse>, I>>(
    object: I,
  ): GetTradeConfigPresetsResponse {
    const message = createBaseGetTradeConfigPresetsResponse();
    message.presets = object.presets?.map((e) => TradeConfigPreset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSetTradeConfigPresetRequest(): SetTradeConfigPresetRequest {
  return { preset: undefined };
}

export const SetTradeConfigPresetRequest: MessageFns<SetTradeConfigPresetRequest> = {
  encode(message: SetTradeConfigPresetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preset !== undefined) {
      TradeConfigPreset.encode(message.preset, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetTradeConfigPresetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetTradeConfigPresetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preset = TradeConfigPreset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetTradeConfigPresetRequest {
    return { preset: isSet(object.preset) ? TradeConfigPreset.fromJSON(object.preset) : undefined };
  },

  toJSON(message: SetTradeConfigPresetRequest): unknown {
    const obj: any = {};
    if (message.preset !== undefined) {
      obj.preset = TradeConfigPreset.toJSON(message.preset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetTradeConfigPresetRequest>, I>>(base?: I): SetTradeConfigPresetRequest {
    return SetTradeConfigPresetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetTradeConfigPresetRequest>, I>>(object: I): SetTradeConfigPresetRequest {
    const message = createBaseSetTradeConfigPresetRequest();
    message.preset = (object.preset !== undefined && object.preset !== null)
      ? TradeConfigPreset.fromPartial(object.preset)
      : undefined;
    return message;
  },
};

function createBaseSetTradeConfigPresetResponse(): SetTradeConfigPresetResponse {
  return { success: false };
}

export const SetTradeConfigPresetResponse: MessageFns<SetTradeConfigPresetResponse> = {
  encode(message: SetTradeConfigPresetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetTradeConfigPresetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetTradeConfigPresetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetTradeConfigPresetResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SetTradeConfigPresetResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetTradeConfigPresetResponse>, I>>(base?: I): SetTradeConfigPresetResponse {
    return SetTradeConfigPresetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetTradeConfigPresetResponse>, I>>(object: I): SetTradeConfigPresetResponse {
    const message = createBaseSetTradeConfigPresetResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export type TradeService = typeof TradeService;
export const TradeService = {
  spotBuy: {
    path: "/trade.Trade/SpotBuy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SpotBuyRequest) => Buffer.from(SpotBuyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SpotBuyRequest.decode(value),
    responseSerialize: (value: SpotBuyResponse) => Buffer.from(SpotBuyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SpotBuyResponse.decode(value),
  },
  spotSell: {
    path: "/trade.Trade/SpotSell",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SpotSellRequest) => Buffer.from(SpotSellRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SpotSellRequest.decode(value),
    responseSerialize: (value: SpotSellResponse) => Buffer.from(SpotSellResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SpotSellResponse.decode(value),
  },
  getTradeConfigPresets: {
    path: "/trade.Trade/GetTradeConfigPresets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTradeConfigPresetsRequest) =>
      Buffer.from(GetTradeConfigPresetsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTradeConfigPresetsRequest.decode(value),
    responseSerialize: (value: GetTradeConfigPresetsResponse) =>
      Buffer.from(GetTradeConfigPresetsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTradeConfigPresetsResponse.decode(value),
  },
  setTradeConfigPreset: {
    path: "/trade.Trade/SetTradeConfigPreset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetTradeConfigPresetRequest) =>
      Buffer.from(SetTradeConfigPresetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SetTradeConfigPresetRequest.decode(value),
    responseSerialize: (value: SetTradeConfigPresetResponse) =>
      Buffer.from(SetTradeConfigPresetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SetTradeConfigPresetResponse.decode(value),
  },
} as const;

export interface TradeServer extends UntypedServiceImplementation {
  spotBuy: handleUnaryCall<SpotBuyRequest, SpotBuyResponse>;
  spotSell: handleUnaryCall<SpotSellRequest, SpotSellResponse>;
  getTradeConfigPresets: handleUnaryCall<GetTradeConfigPresetsRequest, GetTradeConfigPresetsResponse>;
  setTradeConfigPreset: handleUnaryCall<SetTradeConfigPresetRequest, SetTradeConfigPresetResponse>;
}

export interface TradeClient extends Client {
  spotBuy(
    request: SpotBuyRequest,
    callback: (error: ServiceError | null, response: SpotBuyResponse) => void,
  ): ClientUnaryCall;
  spotBuy(
    request: SpotBuyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SpotBuyResponse) => void,
  ): ClientUnaryCall;
  spotBuy(
    request: SpotBuyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SpotBuyResponse) => void,
  ): ClientUnaryCall;
  spotSell(
    request: SpotSellRequest,
    callback: (error: ServiceError | null, response: SpotSellResponse) => void,
  ): ClientUnaryCall;
  spotSell(
    request: SpotSellRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SpotSellResponse) => void,
  ): ClientUnaryCall;
  spotSell(
    request: SpotSellRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SpotSellResponse) => void,
  ): ClientUnaryCall;
  getTradeConfigPresets(
    request: GetTradeConfigPresetsRequest,
    callback: (error: ServiceError | null, response: GetTradeConfigPresetsResponse) => void,
  ): ClientUnaryCall;
  getTradeConfigPresets(
    request: GetTradeConfigPresetsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTradeConfigPresetsResponse) => void,
  ): ClientUnaryCall;
  getTradeConfigPresets(
    request: GetTradeConfigPresetsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTradeConfigPresetsResponse) => void,
  ): ClientUnaryCall;
  setTradeConfigPreset(
    request: SetTradeConfigPresetRequest,
    callback: (error: ServiceError | null, response: SetTradeConfigPresetResponse) => void,
  ): ClientUnaryCall;
  setTradeConfigPreset(
    request: SetTradeConfigPresetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SetTradeConfigPresetResponse) => void,
  ): ClientUnaryCall;
  setTradeConfigPreset(
    request: SetTradeConfigPresetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SetTradeConfigPresetResponse) => void,
  ): ClientUnaryCall;
}

export const TradeClient = makeGenericClientConstructor(TradeService, "trade.Trade") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): TradeClient;
  service: typeof TradeService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
