// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: service/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "auth";

export interface User {
  uuid: string;
  telegramId: string;
  username?: string | undefined;
  pfpUrl?: string | undefined;
  referralTag?: string | undefined;
  referrer?: string | undefined;
  primaryWalletPubKey?: string | undefined;
  xp?: number | undefined;
}

export interface Session {
  sessionUuid: string;
  userUuid: string;
  fingerprint: string;
  isActive: boolean;
  nonce: string;
  sessionToken: string;
  sessionInfo?: string | undefined;
  createdAt: number;
  lastActiveAt: number;
}

export interface Wallet {
  publicKey: string;
  name: string;
  balance?: number | undefined;
}

export interface VerifyPasswordRequest {
  password: string;
}

export interface VerifyPasswordResponse {
  success: boolean;
}

export interface LogoutRequest {
}

export interface LogoutResponse {
  success: boolean;
}

export interface LogoutAllRequest {
}

export interface LogoutAllResponse {
  success: boolean;
}

export interface GetAllSessionInfosRequest {
}

export interface GetAllSessionInfosResponse {
  sessionInfo: string[];
}

export interface CreateSessionRequest {
  telegramId: string;
  username: string;
  fingerprint: string;
  referrer: string;
}

export interface CreateSessionResponse {
  nonce: string;
}

export interface NonceExchangeRequest {
  nonce: string;
  fingerprint: string;
  sessionInfo: string;
}

export interface NonceExchangeResponse {
  sessionToken: string;
}

export interface GetUserBySessionRequest {
}

export interface GetUserBySessionResponse {
  session: Session | undefined;
  user: User | undefined;
  wallets: Wallet[];
}

export interface InitializeUserRequest {
  password: string;
  nonce: string;
}

export interface InitializeUserResponse {
  encryptedMnemonic: string;
  primaryWalletPubKey: string;
}

export interface GetWithdrawWalletsRequest {
}

export interface GetWithdrawWalletsResponse {
  wallets: Wallet[];
}

export interface AddWithdrawWalletRequest {
  publicKey: string;
  name: string;
}

export interface AddWithdrawWalletResponse {
  success: boolean;
}

export interface RemoveWithdrawWalletRequest {
  publicKey: string;
}

export interface RemoveWithdrawWalletResponse {
  success: boolean;
}

export interface WithdrawFromWalletRequest {
  fromPubKey: string;
  toPubKey: string;
  amount: number;
  password: string;
}

export interface WithdrawFromWalletResponse {
  success: boolean;
}

export interface ResetDbRequest {
}

export interface ResetDbResponse {
}

export interface SetReferralTagRequest {
  referralTag: string;
}

export interface SetReferralTagResponse {
  success: boolean;
}

export interface CreateNewWalletRequest {
  password: string;
  name: string;
}

export interface CreateNewWalletResponse {
  success: boolean;
}

export interface GetWalletsRequest {
}

export interface GetWalletsResponse {
  wallets: Wallet[];
}

export interface SwitchPrimaryWalletRequest {
  publicKey: string;
}

export interface SwitchPrimaryWalletResponse {
  success: boolean;
}

export interface RenameWalletRequest {
  publicKey: string;
  name: string;
}

export interface RenameWalletResponse {
  success: boolean;
}

function createBaseUser(): User {
  return {
    uuid: "",
    telegramId: "",
    username: undefined,
    pfpUrl: undefined,
    referralTag: undefined,
    referrer: undefined,
    primaryWalletPubKey: undefined,
    xp: undefined,
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.telegramId !== "") {
      writer.uint32(18).string(message.telegramId);
    }
    if (message.username !== undefined) {
      writer.uint32(26).string(message.username);
    }
    if (message.pfpUrl !== undefined) {
      writer.uint32(34).string(message.pfpUrl);
    }
    if (message.referralTag !== undefined) {
      writer.uint32(42).string(message.referralTag);
    }
    if (message.referrer !== undefined) {
      writer.uint32(50).string(message.referrer);
    }
    if (message.primaryWalletPubKey !== undefined) {
      writer.uint32(58).string(message.primaryWalletPubKey);
    }
    if (message.xp !== undefined) {
      writer.uint32(64).int32(message.xp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telegramId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pfpUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referralTag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.referrer = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.primaryWalletPubKey = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.xp = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      telegramId: isSet(object.telegramId) ? globalThis.String(object.telegramId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      pfpUrl: isSet(object.pfpUrl) ? globalThis.String(object.pfpUrl) : undefined,
      referralTag: isSet(object.referralTag) ? globalThis.String(object.referralTag) : undefined,
      referrer: isSet(object.referrer) ? globalThis.String(object.referrer) : undefined,
      primaryWalletPubKey: isSet(object.primaryWalletPubKey)
        ? globalThis.String(object.primaryWalletPubKey)
        : undefined,
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.telegramId !== "") {
      obj.telegramId = message.telegramId;
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.pfpUrl !== undefined) {
      obj.pfpUrl = message.pfpUrl;
    }
    if (message.referralTag !== undefined) {
      obj.referralTag = message.referralTag;
    }
    if (message.referrer !== undefined) {
      obj.referrer = message.referrer;
    }
    if (message.primaryWalletPubKey !== undefined) {
      obj.primaryWalletPubKey = message.primaryWalletPubKey;
    }
    if (message.xp !== undefined) {
      obj.xp = Math.round(message.xp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.uuid = object.uuid ?? "";
    message.telegramId = object.telegramId ?? "";
    message.username = object.username ?? undefined;
    message.pfpUrl = object.pfpUrl ?? undefined;
    message.referralTag = object.referralTag ?? undefined;
    message.referrer = object.referrer ?? undefined;
    message.primaryWalletPubKey = object.primaryWalletPubKey ?? undefined;
    message.xp = object.xp ?? undefined;
    return message;
  },
};

function createBaseSession(): Session {
  return {
    sessionUuid: "",
    userUuid: "",
    fingerprint: "",
    isActive: false,
    nonce: "",
    sessionToken: "",
    sessionInfo: undefined,
    createdAt: 0,
    lastActiveAt: 0,
  };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionUuid !== "") {
      writer.uint32(10).string(message.sessionUuid);
    }
    if (message.userUuid !== "") {
      writer.uint32(18).string(message.userUuid);
    }
    if (message.fingerprint !== "") {
      writer.uint32(26).string(message.fingerprint);
    }
    if (message.isActive !== false) {
      writer.uint32(32).bool(message.isActive);
    }
    if (message.nonce !== "") {
      writer.uint32(42).string(message.nonce);
    }
    if (message.sessionToken !== "") {
      writer.uint32(50).string(message.sessionToken);
    }
    if (message.sessionInfo !== undefined) {
      writer.uint32(58).string(message.sessionInfo);
    }
    if (message.createdAt !== 0) {
      writer.uint32(64).int32(message.createdAt);
    }
    if (message.lastActiveAt !== 0) {
      writer.uint32(72).int32(message.lastActiveAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userUuid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sessionInfo = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.lastActiveAt = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      sessionUuid: isSet(object.sessionUuid) ? globalThis.String(object.sessionUuid) : "",
      userUuid: isSet(object.userUuid) ? globalThis.String(object.userUuid) : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "",
      sessionInfo: isSet(object.sessionInfo) ? globalThis.String(object.sessionInfo) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      lastActiveAt: isSet(object.lastActiveAt) ? globalThis.Number(object.lastActiveAt) : 0,
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.sessionUuid !== "") {
      obj.sessionUuid = message.sessionUuid;
    }
    if (message.userUuid !== "") {
      obj.userUuid = message.userUuid;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    if (message.sessionInfo !== undefined) {
      obj.sessionInfo = message.sessionInfo;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.lastActiveAt !== 0) {
      obj.lastActiveAt = Math.round(message.lastActiveAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.sessionUuid = object.sessionUuid ?? "";
    message.userUuid = object.userUuid ?? "";
    message.fingerprint = object.fingerprint ?? "";
    message.isActive = object.isActive ?? false;
    message.nonce = object.nonce ?? "";
    message.sessionToken = object.sessionToken ?? "";
    message.sessionInfo = object.sessionInfo ?? undefined;
    message.createdAt = object.createdAt ?? 0;
    message.lastActiveAt = object.lastActiveAt ?? 0;
    return message;
  },
};

function createBaseWallet(): Wallet {
  return { publicKey: "", name: "", balance: undefined };
}

export const Wallet: MessageFns<Wallet> = {
  encode(message: Wallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.balance !== undefined) {
      writer.uint32(25).double(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.balance = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wallet {
    return {
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : undefined,
    };
  },

  toJSON(message: Wallet): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.balance !== undefined) {
      obj.balance = message.balance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wallet>, I>>(base?: I): Wallet {
    return Wallet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wallet>, I>>(object: I): Wallet {
    const message = createBaseWallet();
    message.publicKey = object.publicKey ?? "";
    message.name = object.name ?? "";
    message.balance = object.balance ?? undefined;
    return message;
  },
};

function createBaseVerifyPasswordRequest(): VerifyPasswordRequest {
  return { password: "" };
}

export const VerifyPasswordRequest: MessageFns<VerifyPasswordRequest> = {
  encode(message: VerifyPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.password !== "") {
      writer.uint32(10).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyPasswordRequest {
    return { password: isSet(object.password) ? globalThis.String(object.password) : "" };
  },

  toJSON(message: VerifyPasswordRequest): unknown {
    const obj: any = {};
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyPasswordRequest>, I>>(base?: I): VerifyPasswordRequest {
    return VerifyPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyPasswordRequest>, I>>(object: I): VerifyPasswordRequest {
    const message = createBaseVerifyPasswordRequest();
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseVerifyPasswordResponse(): VerifyPasswordResponse {
  return { success: false };
}

export const VerifyPasswordResponse: MessageFns<VerifyPasswordResponse> = {
  encode(message: VerifyPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyPasswordResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: VerifyPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyPasswordResponse>, I>>(base?: I): VerifyPasswordResponse {
    return VerifyPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyPasswordResponse>, I>>(object: I): VerifyPasswordResponse {
    const message = createBaseVerifyPasswordResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseLogoutRequest(): LogoutRequest {
  return {};
}

export const LogoutRequest: MessageFns<LogoutRequest> = {
  encode(_: LogoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LogoutRequest {
    return {};
  },

  toJSON(_: LogoutRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutRequest>, I>>(base?: I): LogoutRequest {
    return LogoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutRequest>, I>>(_: I): LogoutRequest {
    const message = createBaseLogoutRequest();
    return message;
  },
};

function createBaseLogoutResponse(): LogoutResponse {
  return { success: false };
}

export const LogoutResponse: MessageFns<LogoutResponse> = {
  encode(message: LogoutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: LogoutResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutResponse>, I>>(base?: I): LogoutResponse {
    return LogoutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutResponse>, I>>(object: I): LogoutResponse {
    const message = createBaseLogoutResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseLogoutAllRequest(): LogoutAllRequest {
  return {};
}

export const LogoutAllRequest: MessageFns<LogoutAllRequest> = {
  encode(_: LogoutAllRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutAllRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LogoutAllRequest {
    return {};
  },

  toJSON(_: LogoutAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutAllRequest>, I>>(base?: I): LogoutAllRequest {
    return LogoutAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutAllRequest>, I>>(_: I): LogoutAllRequest {
    const message = createBaseLogoutAllRequest();
    return message;
  },
};

function createBaseLogoutAllResponse(): LogoutAllResponse {
  return { success: false };
}

export const LogoutAllResponse: MessageFns<LogoutAllResponse> = {
  encode(message: LogoutAllResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutAllResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutAllResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: LogoutAllResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutAllResponse>, I>>(base?: I): LogoutAllResponse {
    return LogoutAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutAllResponse>, I>>(object: I): LogoutAllResponse {
    const message = createBaseLogoutAllResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetAllSessionInfosRequest(): GetAllSessionInfosRequest {
  return {};
}

export const GetAllSessionInfosRequest: MessageFns<GetAllSessionInfosRequest> = {
  encode(_: GetAllSessionInfosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllSessionInfosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllSessionInfosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllSessionInfosRequest {
    return {};
  },

  toJSON(_: GetAllSessionInfosRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllSessionInfosRequest>, I>>(base?: I): GetAllSessionInfosRequest {
    return GetAllSessionInfosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllSessionInfosRequest>, I>>(_: I): GetAllSessionInfosRequest {
    const message = createBaseGetAllSessionInfosRequest();
    return message;
  },
};

function createBaseGetAllSessionInfosResponse(): GetAllSessionInfosResponse {
  return { sessionInfo: [] };
}

export const GetAllSessionInfosResponse: MessageFns<GetAllSessionInfosResponse> = {
  encode(message: GetAllSessionInfosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessionInfo) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllSessionInfosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllSessionInfosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionInfo.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllSessionInfosResponse {
    return {
      sessionInfo: globalThis.Array.isArray(object?.sessionInfo)
        ? object.sessionInfo.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetAllSessionInfosResponse): unknown {
    const obj: any = {};
    if (message.sessionInfo?.length) {
      obj.sessionInfo = message.sessionInfo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllSessionInfosResponse>, I>>(base?: I): GetAllSessionInfosResponse {
    return GetAllSessionInfosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllSessionInfosResponse>, I>>(object: I): GetAllSessionInfosResponse {
    const message = createBaseGetAllSessionInfosResponse();
    message.sessionInfo = object.sessionInfo?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { telegramId: "", username: "", fingerprint: "", referrer: "" };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.telegramId !== "") {
      writer.uint32(10).string(message.telegramId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.fingerprint !== "") {
      writer.uint32(26).string(message.fingerprint);
    }
    if (message.referrer !== "") {
      writer.uint32(34).string(message.referrer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.telegramId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.referrer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      telegramId: isSet(object.telegramId) ? globalThis.String(object.telegramId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      referrer: isSet(object.referrer) ? globalThis.String(object.referrer) : "",
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.telegramId !== "") {
      obj.telegramId = message.telegramId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.referrer !== "") {
      obj.referrer = message.referrer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.telegramId = object.telegramId ?? "";
    message.username = object.username ?? "";
    message.fingerprint = object.fingerprint ?? "";
    message.referrer = object.referrer ?? "";
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { nonce: "" };
}

export const CreateSessionResponse: MessageFns<CreateSessionResponse> = {
  encode(message: CreateSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonce !== "") {
      writer.uint32(10).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return { nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "" };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(base?: I): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(object: I): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseNonceExchangeRequest(): NonceExchangeRequest {
  return { nonce: "", fingerprint: "", sessionInfo: "" };
}

export const NonceExchangeRequest: MessageFns<NonceExchangeRequest> = {
  encode(message: NonceExchangeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonce !== "") {
      writer.uint32(10).string(message.nonce);
    }
    if (message.fingerprint !== "") {
      writer.uint32(18).string(message.fingerprint);
    }
    if (message.sessionInfo !== "") {
      writer.uint32(26).string(message.sessionInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NonceExchangeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonceExchangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionInfo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NonceExchangeRequest {
    return {
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      sessionInfo: isSet(object.sessionInfo) ? globalThis.String(object.sessionInfo) : "",
    };
  },

  toJSON(message: NonceExchangeRequest): unknown {
    const obj: any = {};
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.sessionInfo !== "") {
      obj.sessionInfo = message.sessionInfo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NonceExchangeRequest>, I>>(base?: I): NonceExchangeRequest {
    return NonceExchangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NonceExchangeRequest>, I>>(object: I): NonceExchangeRequest {
    const message = createBaseNonceExchangeRequest();
    message.nonce = object.nonce ?? "";
    message.fingerprint = object.fingerprint ?? "";
    message.sessionInfo = object.sessionInfo ?? "";
    return message;
  },
};

function createBaseNonceExchangeResponse(): NonceExchangeResponse {
  return { sessionToken: "" };
}

export const NonceExchangeResponse: MessageFns<NonceExchangeResponse> = {
  encode(message: NonceExchangeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NonceExchangeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNonceExchangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NonceExchangeResponse {
    return { sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : "" };
  },

  toJSON(message: NonceExchangeResponse): unknown {
    const obj: any = {};
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NonceExchangeResponse>, I>>(base?: I): NonceExchangeResponse {
    return NonceExchangeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NonceExchangeResponse>, I>>(object: I): NonceExchangeResponse {
    const message = createBaseNonceExchangeResponse();
    message.sessionToken = object.sessionToken ?? "";
    return message;
  },
};

function createBaseGetUserBySessionRequest(): GetUserBySessionRequest {
  return {};
}

export const GetUserBySessionRequest: MessageFns<GetUserBySessionRequest> = {
  encode(_: GetUserBySessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserBySessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserBySessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetUserBySessionRequest {
    return {};
  },

  toJSON(_: GetUserBySessionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserBySessionRequest>, I>>(base?: I): GetUserBySessionRequest {
    return GetUserBySessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserBySessionRequest>, I>>(_: I): GetUserBySessionRequest {
    const message = createBaseGetUserBySessionRequest();
    return message;
  },
};

function createBaseGetUserBySessionResponse(): GetUserBySessionResponse {
  return { session: undefined, user: undefined, wallets: [] };
}

export const GetUserBySessionResponse: MessageFns<GetUserBySessionResponse> = {
  encode(message: GetUserBySessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    for (const v of message.wallets) {
      Wallet.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserBySessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserBySessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wallets.push(Wallet.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserBySessionResponse {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      wallets: globalThis.Array.isArray(object?.wallets) ? object.wallets.map((e: any) => Wallet.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetUserBySessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => Wallet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserBySessionResponse>, I>>(base?: I): GetUserBySessionResponse {
    return GetUserBySessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserBySessionResponse>, I>>(object: I): GetUserBySessionResponse {
    const message = createBaseGetUserBySessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.wallets = object.wallets?.map((e) => Wallet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInitializeUserRequest(): InitializeUserRequest {
  return { password: "", nonce: "" };
}

export const InitializeUserRequest: MessageFns<InitializeUserRequest> = {
  encode(message: InitializeUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.password !== "") {
      writer.uint32(10).string(message.password);
    }
    if (message.nonce !== "") {
      writer.uint32(18).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializeUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitializeUserRequest {
    return {
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: InitializeUserRequest): unknown {
    const obj: any = {};
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitializeUserRequest>, I>>(base?: I): InitializeUserRequest {
    return InitializeUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitializeUserRequest>, I>>(object: I): InitializeUserRequest {
    const message = createBaseInitializeUserRequest();
    message.password = object.password ?? "";
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseInitializeUserResponse(): InitializeUserResponse {
  return { encryptedMnemonic: "", primaryWalletPubKey: "" };
}

export const InitializeUserResponse: MessageFns<InitializeUserResponse> = {
  encode(message: InitializeUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encryptedMnemonic !== "") {
      writer.uint32(10).string(message.encryptedMnemonic);
    }
    if (message.primaryWalletPubKey !== "") {
      writer.uint32(18).string(message.primaryWalletPubKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializeUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encryptedMnemonic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.primaryWalletPubKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitializeUserResponse {
    return {
      encryptedMnemonic: isSet(object.encryptedMnemonic) ? globalThis.String(object.encryptedMnemonic) : "",
      primaryWalletPubKey: isSet(object.primaryWalletPubKey) ? globalThis.String(object.primaryWalletPubKey) : "",
    };
  },

  toJSON(message: InitializeUserResponse): unknown {
    const obj: any = {};
    if (message.encryptedMnemonic !== "") {
      obj.encryptedMnemonic = message.encryptedMnemonic;
    }
    if (message.primaryWalletPubKey !== "") {
      obj.primaryWalletPubKey = message.primaryWalletPubKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitializeUserResponse>, I>>(base?: I): InitializeUserResponse {
    return InitializeUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitializeUserResponse>, I>>(object: I): InitializeUserResponse {
    const message = createBaseInitializeUserResponse();
    message.encryptedMnemonic = object.encryptedMnemonic ?? "";
    message.primaryWalletPubKey = object.primaryWalletPubKey ?? "";
    return message;
  },
};

function createBaseGetWithdrawWalletsRequest(): GetWithdrawWalletsRequest {
  return {};
}

export const GetWithdrawWalletsRequest: MessageFns<GetWithdrawWalletsRequest> = {
  encode(_: GetWithdrawWalletsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWithdrawWalletsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWithdrawWalletsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetWithdrawWalletsRequest {
    return {};
  },

  toJSON(_: GetWithdrawWalletsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWithdrawWalletsRequest>, I>>(base?: I): GetWithdrawWalletsRequest {
    return GetWithdrawWalletsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWithdrawWalletsRequest>, I>>(_: I): GetWithdrawWalletsRequest {
    const message = createBaseGetWithdrawWalletsRequest();
    return message;
  },
};

function createBaseGetWithdrawWalletsResponse(): GetWithdrawWalletsResponse {
  return { wallets: [] };
}

export const GetWithdrawWalletsResponse: MessageFns<GetWithdrawWalletsResponse> = {
  encode(message: GetWithdrawWalletsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.wallets) {
      Wallet.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWithdrawWalletsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWithdrawWalletsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wallets.push(Wallet.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWithdrawWalletsResponse {
    return {
      wallets: globalThis.Array.isArray(object?.wallets) ? object.wallets.map((e: any) => Wallet.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetWithdrawWalletsResponse): unknown {
    const obj: any = {};
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => Wallet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWithdrawWalletsResponse>, I>>(base?: I): GetWithdrawWalletsResponse {
    return GetWithdrawWalletsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWithdrawWalletsResponse>, I>>(object: I): GetWithdrawWalletsResponse {
    const message = createBaseGetWithdrawWalletsResponse();
    message.wallets = object.wallets?.map((e) => Wallet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddWithdrawWalletRequest(): AddWithdrawWalletRequest {
  return { publicKey: "", name: "" };
}

export const AddWithdrawWalletRequest: MessageFns<AddWithdrawWalletRequest> = {
  encode(message: AddWithdrawWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddWithdrawWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddWithdrawWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddWithdrawWalletRequest {
    return {
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: AddWithdrawWalletRequest): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddWithdrawWalletRequest>, I>>(base?: I): AddWithdrawWalletRequest {
    return AddWithdrawWalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddWithdrawWalletRequest>, I>>(object: I): AddWithdrawWalletRequest {
    const message = createBaseAddWithdrawWalletRequest();
    message.publicKey = object.publicKey ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAddWithdrawWalletResponse(): AddWithdrawWalletResponse {
  return { success: false };
}

export const AddWithdrawWalletResponse: MessageFns<AddWithdrawWalletResponse> = {
  encode(message: AddWithdrawWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddWithdrawWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddWithdrawWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddWithdrawWalletResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: AddWithdrawWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddWithdrawWalletResponse>, I>>(base?: I): AddWithdrawWalletResponse {
    return AddWithdrawWalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddWithdrawWalletResponse>, I>>(object: I): AddWithdrawWalletResponse {
    const message = createBaseAddWithdrawWalletResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseRemoveWithdrawWalletRequest(): RemoveWithdrawWalletRequest {
  return { publicKey: "" };
}

export const RemoveWithdrawWalletRequest: MessageFns<RemoveWithdrawWalletRequest> = {
  encode(message: RemoveWithdrawWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveWithdrawWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveWithdrawWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveWithdrawWalletRequest {
    return { publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "" };
  },

  toJSON(message: RemoveWithdrawWalletRequest): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveWithdrawWalletRequest>, I>>(base?: I): RemoveWithdrawWalletRequest {
    return RemoveWithdrawWalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveWithdrawWalletRequest>, I>>(object: I): RemoveWithdrawWalletRequest {
    const message = createBaseRemoveWithdrawWalletRequest();
    message.publicKey = object.publicKey ?? "";
    return message;
  },
};

function createBaseRemoveWithdrawWalletResponse(): RemoveWithdrawWalletResponse {
  return { success: false };
}

export const RemoveWithdrawWalletResponse: MessageFns<RemoveWithdrawWalletResponse> = {
  encode(message: RemoveWithdrawWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveWithdrawWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveWithdrawWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveWithdrawWalletResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RemoveWithdrawWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveWithdrawWalletResponse>, I>>(base?: I): RemoveWithdrawWalletResponse {
    return RemoveWithdrawWalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveWithdrawWalletResponse>, I>>(object: I): RemoveWithdrawWalletResponse {
    const message = createBaseRemoveWithdrawWalletResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseWithdrawFromWalletRequest(): WithdrawFromWalletRequest {
  return { fromPubKey: "", toPubKey: "", amount: 0, password: "" };
}

export const WithdrawFromWalletRequest: MessageFns<WithdrawFromWalletRequest> = {
  encode(message: WithdrawFromWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromPubKey !== "") {
      writer.uint32(10).string(message.fromPubKey);
    }
    if (message.toPubKey !== "") {
      writer.uint32(26).string(message.toPubKey);
    }
    if (message.amount !== 0) {
      writer.uint32(21).float(message.amount);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawFromWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawFromWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromPubKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toPubKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.amount = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawFromWalletRequest {
    return {
      fromPubKey: isSet(object.fromPubKey) ? globalThis.String(object.fromPubKey) : "",
      toPubKey: isSet(object.toPubKey) ? globalThis.String(object.toPubKey) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: WithdrawFromWalletRequest): unknown {
    const obj: any = {};
    if (message.fromPubKey !== "") {
      obj.fromPubKey = message.fromPubKey;
    }
    if (message.toPubKey !== "") {
      obj.toPubKey = message.toPubKey;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawFromWalletRequest>, I>>(base?: I): WithdrawFromWalletRequest {
    return WithdrawFromWalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawFromWalletRequest>, I>>(object: I): WithdrawFromWalletRequest {
    const message = createBaseWithdrawFromWalletRequest();
    message.fromPubKey = object.fromPubKey ?? "";
    message.toPubKey = object.toPubKey ?? "";
    message.amount = object.amount ?? 0;
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseWithdrawFromWalletResponse(): WithdrawFromWalletResponse {
  return { success: false };
}

export const WithdrawFromWalletResponse: MessageFns<WithdrawFromWalletResponse> = {
  encode(message: WithdrawFromWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawFromWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawFromWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawFromWalletResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: WithdrawFromWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawFromWalletResponse>, I>>(base?: I): WithdrawFromWalletResponse {
    return WithdrawFromWalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawFromWalletResponse>, I>>(object: I): WithdrawFromWalletResponse {
    const message = createBaseWithdrawFromWalletResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseResetDbRequest(): ResetDbRequest {
  return {};
}

export const ResetDbRequest: MessageFns<ResetDbRequest> = {
  encode(_: ResetDbRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetDbRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetDbRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetDbRequest {
    return {};
  },

  toJSON(_: ResetDbRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetDbRequest>, I>>(base?: I): ResetDbRequest {
    return ResetDbRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetDbRequest>, I>>(_: I): ResetDbRequest {
    const message = createBaseResetDbRequest();
    return message;
  },
};

function createBaseResetDbResponse(): ResetDbResponse {
  return {};
}

export const ResetDbResponse: MessageFns<ResetDbResponse> = {
  encode(_: ResetDbResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetDbResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetDbResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetDbResponse {
    return {};
  },

  toJSON(_: ResetDbResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetDbResponse>, I>>(base?: I): ResetDbResponse {
    return ResetDbResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetDbResponse>, I>>(_: I): ResetDbResponse {
    const message = createBaseResetDbResponse();
    return message;
  },
};

function createBaseSetReferralTagRequest(): SetReferralTagRequest {
  return { referralTag: "" };
}

export const SetReferralTagRequest: MessageFns<SetReferralTagRequest> = {
  encode(message: SetReferralTagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referralTag !== "") {
      writer.uint32(10).string(message.referralTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetReferralTagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetReferralTagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referralTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetReferralTagRequest {
    return { referralTag: isSet(object.referralTag) ? globalThis.String(object.referralTag) : "" };
  },

  toJSON(message: SetReferralTagRequest): unknown {
    const obj: any = {};
    if (message.referralTag !== "") {
      obj.referralTag = message.referralTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetReferralTagRequest>, I>>(base?: I): SetReferralTagRequest {
    return SetReferralTagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetReferralTagRequest>, I>>(object: I): SetReferralTagRequest {
    const message = createBaseSetReferralTagRequest();
    message.referralTag = object.referralTag ?? "";
    return message;
  },
};

function createBaseSetReferralTagResponse(): SetReferralTagResponse {
  return { success: false };
}

export const SetReferralTagResponse: MessageFns<SetReferralTagResponse> = {
  encode(message: SetReferralTagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetReferralTagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetReferralTagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetReferralTagResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SetReferralTagResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetReferralTagResponse>, I>>(base?: I): SetReferralTagResponse {
    return SetReferralTagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetReferralTagResponse>, I>>(object: I): SetReferralTagResponse {
    const message = createBaseSetReferralTagResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCreateNewWalletRequest(): CreateNewWalletRequest {
  return { password: "", name: "" };
}

export const CreateNewWalletRequest: MessageFns<CreateNewWalletRequest> = {
  encode(message: CreateNewWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.password !== "") {
      writer.uint32(10).string(message.password);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNewWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNewWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNewWalletRequest {
    return {
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CreateNewWalletRequest): unknown {
    const obj: any = {};
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNewWalletRequest>, I>>(base?: I): CreateNewWalletRequest {
    return CreateNewWalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNewWalletRequest>, I>>(object: I): CreateNewWalletRequest {
    const message = createBaseCreateNewWalletRequest();
    message.password = object.password ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNewWalletResponse(): CreateNewWalletResponse {
  return { success: false };
}

export const CreateNewWalletResponse: MessageFns<CreateNewWalletResponse> = {
  encode(message: CreateNewWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNewWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNewWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNewWalletResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CreateNewWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNewWalletResponse>, I>>(base?: I): CreateNewWalletResponse {
    return CreateNewWalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNewWalletResponse>, I>>(object: I): CreateNewWalletResponse {
    const message = createBaseCreateNewWalletResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetWalletsRequest(): GetWalletsRequest {
  return {};
}

export const GetWalletsRequest: MessageFns<GetWalletsRequest> = {
  encode(_: GetWalletsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetWalletsRequest {
    return {};
  },

  toJSON(_: GetWalletsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletsRequest>, I>>(base?: I): GetWalletsRequest {
    return GetWalletsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletsRequest>, I>>(_: I): GetWalletsRequest {
    const message = createBaseGetWalletsRequest();
    return message;
  },
};

function createBaseGetWalletsResponse(): GetWalletsResponse {
  return { wallets: [] };
}

export const GetWalletsResponse: MessageFns<GetWalletsResponse> = {
  encode(message: GetWalletsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.wallets) {
      Wallet.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wallets.push(Wallet.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletsResponse {
    return {
      wallets: globalThis.Array.isArray(object?.wallets) ? object.wallets.map((e: any) => Wallet.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetWalletsResponse): unknown {
    const obj: any = {};
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => Wallet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletsResponse>, I>>(base?: I): GetWalletsResponse {
    return GetWalletsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletsResponse>, I>>(object: I): GetWalletsResponse {
    const message = createBaseGetWalletsResponse();
    message.wallets = object.wallets?.map((e) => Wallet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSwitchPrimaryWalletRequest(): SwitchPrimaryWalletRequest {
  return { publicKey: "" };
}

export const SwitchPrimaryWalletRequest: MessageFns<SwitchPrimaryWalletRequest> = {
  encode(message: SwitchPrimaryWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwitchPrimaryWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchPrimaryWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwitchPrimaryWalletRequest {
    return { publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "" };
  },

  toJSON(message: SwitchPrimaryWalletRequest): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwitchPrimaryWalletRequest>, I>>(base?: I): SwitchPrimaryWalletRequest {
    return SwitchPrimaryWalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwitchPrimaryWalletRequest>, I>>(object: I): SwitchPrimaryWalletRequest {
    const message = createBaseSwitchPrimaryWalletRequest();
    message.publicKey = object.publicKey ?? "";
    return message;
  },
};

function createBaseSwitchPrimaryWalletResponse(): SwitchPrimaryWalletResponse {
  return { success: false };
}

export const SwitchPrimaryWalletResponse: MessageFns<SwitchPrimaryWalletResponse> = {
  encode(message: SwitchPrimaryWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwitchPrimaryWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchPrimaryWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwitchPrimaryWalletResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SwitchPrimaryWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwitchPrimaryWalletResponse>, I>>(base?: I): SwitchPrimaryWalletResponse {
    return SwitchPrimaryWalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwitchPrimaryWalletResponse>, I>>(object: I): SwitchPrimaryWalletResponse {
    const message = createBaseSwitchPrimaryWalletResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseRenameWalletRequest(): RenameWalletRequest {
  return { publicKey: "", name: "" };
}

export const RenameWalletRequest: MessageFns<RenameWalletRequest> = {
  encode(message: RenameWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameWalletRequest {
    return {
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: RenameWalletRequest): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenameWalletRequest>, I>>(base?: I): RenameWalletRequest {
    return RenameWalletRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenameWalletRequest>, I>>(object: I): RenameWalletRequest {
    const message = createBaseRenameWalletRequest();
    message.publicKey = object.publicKey ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRenameWalletResponse(): RenameWalletResponse {
  return { success: false };
}

export const RenameWalletResponse: MessageFns<RenameWalletResponse> = {
  encode(message: RenameWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameWalletResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RenameWalletResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenameWalletResponse>, I>>(base?: I): RenameWalletResponse {
    return RenameWalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenameWalletResponse>, I>>(object: I): RenameWalletResponse {
    const message = createBaseRenameWalletResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export type AuthService = typeof AuthService;
export const AuthService = {
  createSession: {
    path: "/auth.Auth/CreateSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSessionRequest) => Buffer.from(CreateSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateSessionRequest.decode(value),
    responseSerialize: (value: CreateSessionResponse) => Buffer.from(CreateSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateSessionResponse.decode(value),
  },
  nonceExchange: {
    path: "/auth.Auth/NonceExchange",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NonceExchangeRequest) => Buffer.from(NonceExchangeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NonceExchangeRequest.decode(value),
    responseSerialize: (value: NonceExchangeResponse) => Buffer.from(NonceExchangeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NonceExchangeResponse.decode(value),
  },
  verifyPassword: {
    path: "/auth.Auth/VerifyPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyPasswordRequest) => Buffer.from(VerifyPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyPasswordRequest.decode(value),
    responseSerialize: (value: VerifyPasswordResponse) => Buffer.from(VerifyPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyPasswordResponse.decode(value),
  },
  getUserBySession: {
    path: "/auth.Auth/GetUserBySession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserBySessionRequest) => Buffer.from(GetUserBySessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserBySessionRequest.decode(value),
    responseSerialize: (value: GetUserBySessionResponse) =>
      Buffer.from(GetUserBySessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserBySessionResponse.decode(value),
  },
  getAllSessionInfos: {
    path: "/auth.Auth/GetAllSessionInfos",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllSessionInfosRequest) =>
      Buffer.from(GetAllSessionInfosRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllSessionInfosRequest.decode(value),
    responseSerialize: (value: GetAllSessionInfosResponse) =>
      Buffer.from(GetAllSessionInfosResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllSessionInfosResponse.decode(value),
  },
  logout: {
    path: "/auth.Auth/Logout",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LogoutRequest) => Buffer.from(LogoutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogoutRequest.decode(value),
    responseSerialize: (value: LogoutResponse) => Buffer.from(LogoutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LogoutResponse.decode(value),
  },
  logoutAll: {
    path: "/auth.Auth/LogoutAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LogoutAllRequest) => Buffer.from(LogoutAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogoutAllRequest.decode(value),
    responseSerialize: (value: LogoutAllResponse) => Buffer.from(LogoutAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LogoutAllResponse.decode(value),
  },
  initializeUser: {
    path: "/auth.Auth/InitializeUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InitializeUserRequest) => Buffer.from(InitializeUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InitializeUserRequest.decode(value),
    responseSerialize: (value: InitializeUserResponse) => Buffer.from(InitializeUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InitializeUserResponse.decode(value),
  },
  getWithdrawWallets: {
    path: "/auth.Auth/GetWithdrawWallets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWithdrawWalletsRequest) =>
      Buffer.from(GetWithdrawWalletsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWithdrawWalletsRequest.decode(value),
    responseSerialize: (value: GetWithdrawWalletsResponse) =>
      Buffer.from(GetWithdrawWalletsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWithdrawWalletsResponse.decode(value),
  },
  addWithdrawWallet: {
    path: "/auth.Auth/AddWithdrawWallet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddWithdrawWalletRequest) => Buffer.from(AddWithdrawWalletRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddWithdrawWalletRequest.decode(value),
    responseSerialize: (value: AddWithdrawWalletResponse) =>
      Buffer.from(AddWithdrawWalletResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddWithdrawWalletResponse.decode(value),
  },
  removeWithdrawWallet: {
    path: "/auth.Auth/RemoveWithdrawWallet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveWithdrawWalletRequest) =>
      Buffer.from(RemoveWithdrawWalletRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveWithdrawWalletRequest.decode(value),
    responseSerialize: (value: RemoveWithdrawWalletResponse) =>
      Buffer.from(RemoveWithdrawWalletResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RemoveWithdrawWalletResponse.decode(value),
  },
  withdrawFromWallet: {
    path: "/auth.Auth/WithdrawFromWallet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WithdrawFromWalletRequest) =>
      Buffer.from(WithdrawFromWalletRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WithdrawFromWalletRequest.decode(value),
    responseSerialize: (value: WithdrawFromWalletResponse) =>
      Buffer.from(WithdrawFromWalletResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WithdrawFromWalletResponse.decode(value),
  },
  setReferralTag: {
    path: "/auth.Auth/SetReferralTag",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetReferralTagRequest) => Buffer.from(SetReferralTagRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SetReferralTagRequest.decode(value),
    responseSerialize: (value: SetReferralTagResponse) => Buffer.from(SetReferralTagResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SetReferralTagResponse.decode(value),
  },
  getWallets: {
    path: "/auth.Auth/GetWallets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWalletsRequest) => Buffer.from(GetWalletsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWalletsRequest.decode(value),
    responseSerialize: (value: GetWalletsResponse) => Buffer.from(GetWalletsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWalletsResponse.decode(value),
  },
  createNewWallet: {
    path: "/auth.Auth/CreateNewWallet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateNewWalletRequest) => Buffer.from(CreateNewWalletRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateNewWalletRequest.decode(value),
    responseSerialize: (value: CreateNewWalletResponse) => Buffer.from(CreateNewWalletResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateNewWalletResponse.decode(value),
  },
  resetDb: {
    path: "/auth.Auth/ResetDb",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetDbRequest) => Buffer.from(ResetDbRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResetDbRequest.decode(value),
    responseSerialize: (value: ResetDbResponse) => Buffer.from(ResetDbResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResetDbResponse.decode(value),
  },
  switchPrimaryWallet: {
    path: "/auth.Auth/SwitchPrimaryWallet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SwitchPrimaryWalletRequest) =>
      Buffer.from(SwitchPrimaryWalletRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SwitchPrimaryWalletRequest.decode(value),
    responseSerialize: (value: SwitchPrimaryWalletResponse) =>
      Buffer.from(SwitchPrimaryWalletResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SwitchPrimaryWalletResponse.decode(value),
  },
  renameWallet: {
    path: "/auth.Auth/RenameWallet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenameWalletRequest) => Buffer.from(RenameWalletRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RenameWalletRequest.decode(value),
    responseSerialize: (value: RenameWalletResponse) => Buffer.from(RenameWalletResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RenameWalletResponse.decode(value),
  },
} as const;

export interface AuthServer extends UntypedServiceImplementation {
  createSession: handleUnaryCall<CreateSessionRequest, CreateSessionResponse>;
  nonceExchange: handleUnaryCall<NonceExchangeRequest, NonceExchangeResponse>;
  verifyPassword: handleUnaryCall<VerifyPasswordRequest, VerifyPasswordResponse>;
  getUserBySession: handleUnaryCall<GetUserBySessionRequest, GetUserBySessionResponse>;
  getAllSessionInfos: handleUnaryCall<GetAllSessionInfosRequest, GetAllSessionInfosResponse>;
  logout: handleUnaryCall<LogoutRequest, LogoutResponse>;
  logoutAll: handleUnaryCall<LogoutAllRequest, LogoutAllResponse>;
  initializeUser: handleUnaryCall<InitializeUserRequest, InitializeUserResponse>;
  getWithdrawWallets: handleUnaryCall<GetWithdrawWalletsRequest, GetWithdrawWalletsResponse>;
  addWithdrawWallet: handleUnaryCall<AddWithdrawWalletRequest, AddWithdrawWalletResponse>;
  removeWithdrawWallet: handleUnaryCall<RemoveWithdrawWalletRequest, RemoveWithdrawWalletResponse>;
  withdrawFromWallet: handleUnaryCall<WithdrawFromWalletRequest, WithdrawFromWalletResponse>;
  setReferralTag: handleUnaryCall<SetReferralTagRequest, SetReferralTagResponse>;
  getWallets: handleUnaryCall<GetWalletsRequest, GetWalletsResponse>;
  createNewWallet: handleUnaryCall<CreateNewWalletRequest, CreateNewWalletResponse>;
  resetDb: handleUnaryCall<ResetDbRequest, ResetDbResponse>;
  switchPrimaryWallet: handleUnaryCall<SwitchPrimaryWalletRequest, SwitchPrimaryWalletResponse>;
  renameWallet: handleUnaryCall<RenameWalletRequest, RenameWalletResponse>;
}

export interface AuthClient extends Client {
  createSession(
    request: CreateSessionRequest,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  nonceExchange(
    request: NonceExchangeRequest,
    callback: (error: ServiceError | null, response: NonceExchangeResponse) => void,
  ): ClientUnaryCall;
  nonceExchange(
    request: NonceExchangeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NonceExchangeResponse) => void,
  ): ClientUnaryCall;
  nonceExchange(
    request: NonceExchangeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NonceExchangeResponse) => void,
  ): ClientUnaryCall;
  verifyPassword(
    request: VerifyPasswordRequest,
    callback: (error: ServiceError | null, response: VerifyPasswordResponse) => void,
  ): ClientUnaryCall;
  verifyPassword(
    request: VerifyPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyPasswordResponse) => void,
  ): ClientUnaryCall;
  verifyPassword(
    request: VerifyPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyPasswordResponse) => void,
  ): ClientUnaryCall;
  getUserBySession(
    request: GetUserBySessionRequest,
    callback: (error: ServiceError | null, response: GetUserBySessionResponse) => void,
  ): ClientUnaryCall;
  getUserBySession(
    request: GetUserBySessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUserBySessionResponse) => void,
  ): ClientUnaryCall;
  getUserBySession(
    request: GetUserBySessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUserBySessionResponse) => void,
  ): ClientUnaryCall;
  getAllSessionInfos(
    request: GetAllSessionInfosRequest,
    callback: (error: ServiceError | null, response: GetAllSessionInfosResponse) => void,
  ): ClientUnaryCall;
  getAllSessionInfos(
    request: GetAllSessionInfosRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllSessionInfosResponse) => void,
  ): ClientUnaryCall;
  getAllSessionInfos(
    request: GetAllSessionInfosRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllSessionInfosResponse) => void,
  ): ClientUnaryCall;
  logout(
    request: LogoutRequest,
    callback: (error: ServiceError | null, response: LogoutResponse) => void,
  ): ClientUnaryCall;
  logout(
    request: LogoutRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LogoutResponse) => void,
  ): ClientUnaryCall;
  logout(
    request: LogoutRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LogoutResponse) => void,
  ): ClientUnaryCall;
  logoutAll(
    request: LogoutAllRequest,
    callback: (error: ServiceError | null, response: LogoutAllResponse) => void,
  ): ClientUnaryCall;
  logoutAll(
    request: LogoutAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LogoutAllResponse) => void,
  ): ClientUnaryCall;
  logoutAll(
    request: LogoutAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LogoutAllResponse) => void,
  ): ClientUnaryCall;
  initializeUser(
    request: InitializeUserRequest,
    callback: (error: ServiceError | null, response: InitializeUserResponse) => void,
  ): ClientUnaryCall;
  initializeUser(
    request: InitializeUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InitializeUserResponse) => void,
  ): ClientUnaryCall;
  initializeUser(
    request: InitializeUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InitializeUserResponse) => void,
  ): ClientUnaryCall;
  getWithdrawWallets(
    request: GetWithdrawWalletsRequest,
    callback: (error: ServiceError | null, response: GetWithdrawWalletsResponse) => void,
  ): ClientUnaryCall;
  getWithdrawWallets(
    request: GetWithdrawWalletsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWithdrawWalletsResponse) => void,
  ): ClientUnaryCall;
  getWithdrawWallets(
    request: GetWithdrawWalletsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWithdrawWalletsResponse) => void,
  ): ClientUnaryCall;
  addWithdrawWallet(
    request: AddWithdrawWalletRequest,
    callback: (error: ServiceError | null, response: AddWithdrawWalletResponse) => void,
  ): ClientUnaryCall;
  addWithdrawWallet(
    request: AddWithdrawWalletRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddWithdrawWalletResponse) => void,
  ): ClientUnaryCall;
  addWithdrawWallet(
    request: AddWithdrawWalletRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddWithdrawWalletResponse) => void,
  ): ClientUnaryCall;
  removeWithdrawWallet(
    request: RemoveWithdrawWalletRequest,
    callback: (error: ServiceError | null, response: RemoveWithdrawWalletResponse) => void,
  ): ClientUnaryCall;
  removeWithdrawWallet(
    request: RemoveWithdrawWalletRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RemoveWithdrawWalletResponse) => void,
  ): ClientUnaryCall;
  removeWithdrawWallet(
    request: RemoveWithdrawWalletRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RemoveWithdrawWalletResponse) => void,
  ): ClientUnaryCall;
  withdrawFromWallet(
    request: WithdrawFromWalletRequest,
    callback: (error: ServiceError | null, response: WithdrawFromWalletResponse) => void,
  ): ClientUnaryCall;
  withdrawFromWallet(
    request: WithdrawFromWalletRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WithdrawFromWalletResponse) => void,
  ): ClientUnaryCall;
  withdrawFromWallet(
    request: WithdrawFromWalletRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WithdrawFromWalletResponse) => void,
  ): ClientUnaryCall;
  setReferralTag(
    request: SetReferralTagRequest,
    callback: (error: ServiceError | null, response: SetReferralTagResponse) => void,
  ): ClientUnaryCall;
  setReferralTag(
    request: SetReferralTagRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SetReferralTagResponse) => void,
  ): ClientUnaryCall;
  setReferralTag(
    request: SetReferralTagRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SetReferralTagResponse) => void,
  ): ClientUnaryCall;
  getWallets(
    request: GetWalletsRequest,
    callback: (error: ServiceError | null, response: GetWalletsResponse) => void,
  ): ClientUnaryCall;
  getWallets(
    request: GetWalletsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWalletsResponse) => void,
  ): ClientUnaryCall;
  getWallets(
    request: GetWalletsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWalletsResponse) => void,
  ): ClientUnaryCall;
  createNewWallet(
    request: CreateNewWalletRequest,
    callback: (error: ServiceError | null, response: CreateNewWalletResponse) => void,
  ): ClientUnaryCall;
  createNewWallet(
    request: CreateNewWalletRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateNewWalletResponse) => void,
  ): ClientUnaryCall;
  createNewWallet(
    request: CreateNewWalletRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateNewWalletResponse) => void,
  ): ClientUnaryCall;
  resetDb(
    request: ResetDbRequest,
    callback: (error: ServiceError | null, response: ResetDbResponse) => void,
  ): ClientUnaryCall;
  resetDb(
    request: ResetDbRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetDbResponse) => void,
  ): ClientUnaryCall;
  resetDb(
    request: ResetDbRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetDbResponse) => void,
  ): ClientUnaryCall;
  switchPrimaryWallet(
    request: SwitchPrimaryWalletRequest,
    callback: (error: ServiceError | null, response: SwitchPrimaryWalletResponse) => void,
  ): ClientUnaryCall;
  switchPrimaryWallet(
    request: SwitchPrimaryWalletRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SwitchPrimaryWalletResponse) => void,
  ): ClientUnaryCall;
  switchPrimaryWallet(
    request: SwitchPrimaryWalletRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SwitchPrimaryWalletResponse) => void,
  ): ClientUnaryCall;
  renameWallet(
    request: RenameWalletRequest,
    callback: (error: ServiceError | null, response: RenameWalletResponse) => void,
  ): ClientUnaryCall;
  renameWallet(
    request: RenameWalletRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RenameWalletResponse) => void,
  ): ClientUnaryCall;
  renameWallet(
    request: RenameWalletRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RenameWalletResponse) => void,
  ): ClientUnaryCall;
}

export const AuthClient = makeGenericClientConstructor(AuthService, "auth.Auth") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthClient;
  service: typeof AuthService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
