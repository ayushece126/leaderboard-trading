// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: message/pg_stream.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "pg_stream";

export interface UpdateTraderStats {
  walletId: bigint;
  wallet: string;
  poolId: bigint;
  pool: string;
  buyVolume: bigint;
  sellVolume: bigint;
  buyTokenVolume: bigint;
  sellTokenVolume: bigint;
  buys: number;
  sells: number;
  pnl: bigint;
}

export interface UpdateMintBalance {
  walletId: bigint;
  wallet: string;
  mintId: bigint;
  mint: string;
  balance: bigint;
  holderSince: number;
}

export interface InsertGlobalWalletTag {
  walletId: bigint;
  wallet: string;
  tagType: string;
  tag: string;
}

export interface InsertWalletTag {
  mintId: bigint;
  mint: string;
  walletId: bigint;
  wallet: string;
  tag: string;
}

export interface UpdateWalletStat {
  walletId: bigint;
  wallet: string;
  balance?: bigint | undefined;
  txCount?: bigint | undefined;
  avgHoldTime?: number | undefined;
}

export interface SetWalletFundedAt {
  walletId: bigint;
  wallet: string;
  fundedAt: number;
}

function createBaseUpdateTraderStats(): UpdateTraderStats {
  return {
    walletId: 0n,
    wallet: "",
    poolId: 0n,
    pool: "",
    buyVolume: 0n,
    sellVolume: 0n,
    buyTokenVolume: 0n,
    sellTokenVolume: 0n,
    buys: 0,
    sells: 0,
    pnl: 0n,
  };
}

export const UpdateTraderStats: MessageFns<UpdateTraderStats> = {
  encode(message: UpdateTraderStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0n) {
      if (BigInt.asUintN(64, message.walletId) !== message.walletId) {
        throw new globalThis.Error("value provided for field message.walletId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    if (message.poolId !== 0n) {
      if (BigInt.asUintN(64, message.poolId) !== message.poolId) {
        throw new globalThis.Error("value provided for field message.poolId of type uint64 too large");
      }
      writer.uint32(24).uint64(message.poolId);
    }
    if (message.pool !== "") {
      writer.uint32(34).string(message.pool);
    }
    if (message.buyVolume !== 0n) {
      if (BigInt.asUintN(64, message.buyVolume) !== message.buyVolume) {
        throw new globalThis.Error("value provided for field message.buyVolume of type uint64 too large");
      }
      writer.uint32(40).uint64(message.buyVolume);
    }
    if (message.sellVolume !== 0n) {
      if (BigInt.asUintN(64, message.sellVolume) !== message.sellVolume) {
        throw new globalThis.Error("value provided for field message.sellVolume of type uint64 too large");
      }
      writer.uint32(48).uint64(message.sellVolume);
    }
    if (message.buyTokenVolume !== 0n) {
      if (BigInt.asUintN(64, message.buyTokenVolume) !== message.buyTokenVolume) {
        throw new globalThis.Error("value provided for field message.buyTokenVolume of type uint64 too large");
      }
      writer.uint32(56).uint64(message.buyTokenVolume);
    }
    if (message.sellTokenVolume !== 0n) {
      if (BigInt.asUintN(64, message.sellTokenVolume) !== message.sellTokenVolume) {
        throw new globalThis.Error("value provided for field message.sellTokenVolume of type uint64 too large");
      }
      writer.uint32(64).uint64(message.sellTokenVolume);
    }
    if (message.buys !== 0) {
      writer.uint32(72).uint32(message.buys);
    }
    if (message.sells !== 0) {
      writer.uint32(80).uint32(message.sells);
    }
    if (message.pnl !== 0n) {
      if (BigInt.asIntN(64, message.pnl) !== message.pnl) {
        throw new globalThis.Error("value provided for field message.pnl of type int64 too large");
      }
      writer.uint32(88).int64(message.pnl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTraderStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTraderStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.poolId = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pool = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.buyVolume = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sellVolume = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.buyTokenVolume = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sellTokenVolume = reader.uint64() as bigint;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.buys = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sells = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.pnl = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTraderStats {
    return {
      walletId: isSet(object.walletId) ? BigInt(object.walletId) : 0n,
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      poolId: isSet(object.poolId) ? BigInt(object.poolId) : 0n,
      pool: isSet(object.pool) ? globalThis.String(object.pool) : "",
      buyVolume: isSet(object.buyVolume) ? BigInt(object.buyVolume) : 0n,
      sellVolume: isSet(object.sellVolume) ? BigInt(object.sellVolume) : 0n,
      buyTokenVolume: isSet(object.buyTokenVolume) ? BigInt(object.buyTokenVolume) : 0n,
      sellTokenVolume: isSet(object.sellTokenVolume) ? BigInt(object.sellTokenVolume) : 0n,
      buys: isSet(object.buys) ? globalThis.Number(object.buys) : 0,
      sells: isSet(object.sells) ? globalThis.Number(object.sells) : 0,
      pnl: isSet(object.pnl) ? BigInt(object.pnl) : 0n,
    };
  },

  toJSON(message: UpdateTraderStats): unknown {
    const obj: any = {};
    if (message.walletId !== 0n) {
      obj.walletId = message.walletId.toString();
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.poolId !== 0n) {
      obj.poolId = message.poolId.toString();
    }
    if (message.pool !== "") {
      obj.pool = message.pool;
    }
    if (message.buyVolume !== 0n) {
      obj.buyVolume = message.buyVolume.toString();
    }
    if (message.sellVolume !== 0n) {
      obj.sellVolume = message.sellVolume.toString();
    }
    if (message.buyTokenVolume !== 0n) {
      obj.buyTokenVolume = message.buyTokenVolume.toString();
    }
    if (message.sellTokenVolume !== 0n) {
      obj.sellTokenVolume = message.sellTokenVolume.toString();
    }
    if (message.buys !== 0) {
      obj.buys = Math.round(message.buys);
    }
    if (message.sells !== 0) {
      obj.sells = Math.round(message.sells);
    }
    if (message.pnl !== 0n) {
      obj.pnl = message.pnl.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTraderStats>, I>>(base?: I): UpdateTraderStats {
    return UpdateTraderStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTraderStats>, I>>(object: I): UpdateTraderStats {
    const message = createBaseUpdateTraderStats();
    message.walletId = object.walletId ?? 0n;
    message.wallet = object.wallet ?? "";
    message.poolId = object.poolId ?? 0n;
    message.pool = object.pool ?? "";
    message.buyVolume = object.buyVolume ?? 0n;
    message.sellVolume = object.sellVolume ?? 0n;
    message.buyTokenVolume = object.buyTokenVolume ?? 0n;
    message.sellTokenVolume = object.sellTokenVolume ?? 0n;
    message.buys = object.buys ?? 0;
    message.sells = object.sells ?? 0;
    message.pnl = object.pnl ?? 0n;
    return message;
  },
};

function createBaseUpdateMintBalance(): UpdateMintBalance {
  return { walletId: 0n, wallet: "", mintId: 0n, mint: "", balance: 0n, holderSince: 0 };
}

export const UpdateMintBalance: MessageFns<UpdateMintBalance> = {
  encode(message: UpdateMintBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0n) {
      if (BigInt.asUintN(64, message.walletId) !== message.walletId) {
        throw new globalThis.Error("value provided for field message.walletId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    if (message.mintId !== 0n) {
      if (BigInt.asUintN(64, message.mintId) !== message.mintId) {
        throw new globalThis.Error("value provided for field message.mintId of type uint64 too large");
      }
      writer.uint32(24).uint64(message.mintId);
    }
    if (message.mint !== "") {
      writer.uint32(34).string(message.mint);
    }
    if (message.balance !== 0n) {
      if (BigInt.asUintN(64, message.balance) !== message.balance) {
        throw new globalThis.Error("value provided for field message.balance of type uint64 too large");
      }
      writer.uint32(40).uint64(message.balance);
    }
    if (message.holderSince !== 0) {
      writer.uint32(48).uint32(message.holderSince);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMintBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMintBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mintId = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.balance = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.holderSince = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMintBalance {
    return {
      walletId: isSet(object.walletId) ? BigInt(object.walletId) : 0n,
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      mintId: isSet(object.mintId) ? BigInt(object.mintId) : 0n,
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      balance: isSet(object.balance) ? BigInt(object.balance) : 0n,
      holderSince: isSet(object.holderSince) ? globalThis.Number(object.holderSince) : 0,
    };
  },

  toJSON(message: UpdateMintBalance): unknown {
    const obj: any = {};
    if (message.walletId !== 0n) {
      obj.walletId = message.walletId.toString();
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.mintId !== 0n) {
      obj.mintId = message.mintId.toString();
    }
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.balance !== 0n) {
      obj.balance = message.balance.toString();
    }
    if (message.holderSince !== 0) {
      obj.holderSince = Math.round(message.holderSince);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateMintBalance>, I>>(base?: I): UpdateMintBalance {
    return UpdateMintBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateMintBalance>, I>>(object: I): UpdateMintBalance {
    const message = createBaseUpdateMintBalance();
    message.walletId = object.walletId ?? 0n;
    message.wallet = object.wallet ?? "";
    message.mintId = object.mintId ?? 0n;
    message.mint = object.mint ?? "";
    message.balance = object.balance ?? 0n;
    message.holderSince = object.holderSince ?? 0;
    return message;
  },
};

function createBaseInsertGlobalWalletTag(): InsertGlobalWalletTag {
  return { walletId: 0n, wallet: "", tagType: "", tag: "" };
}

export const InsertGlobalWalletTag: MessageFns<InsertGlobalWalletTag> = {
  encode(message: InsertGlobalWalletTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0n) {
      if (BigInt.asUintN(64, message.walletId) !== message.walletId) {
        throw new globalThis.Error("value provided for field message.walletId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    if (message.tagType !== "") {
      writer.uint32(26).string(message.tagType);
    }
    if (message.tag !== "") {
      writer.uint32(34).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertGlobalWalletTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertGlobalWalletTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tagType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertGlobalWalletTag {
    return {
      walletId: isSet(object.walletId) ? BigInt(object.walletId) : 0n,
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      tagType: isSet(object.tagType) ? globalThis.String(object.tagType) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: InsertGlobalWalletTag): unknown {
    const obj: any = {};
    if (message.walletId !== 0n) {
      obj.walletId = message.walletId.toString();
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.tagType !== "") {
      obj.tagType = message.tagType;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertGlobalWalletTag>, I>>(base?: I): InsertGlobalWalletTag {
    return InsertGlobalWalletTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertGlobalWalletTag>, I>>(object: I): InsertGlobalWalletTag {
    const message = createBaseInsertGlobalWalletTag();
    message.walletId = object.walletId ?? 0n;
    message.wallet = object.wallet ?? "";
    message.tagType = object.tagType ?? "";
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseInsertWalletTag(): InsertWalletTag {
  return { mintId: 0n, mint: "", walletId: 0n, wallet: "", tag: "" };
}

export const InsertWalletTag: MessageFns<InsertWalletTag> = {
  encode(message: InsertWalletTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mintId !== 0n) {
      if (BigInt.asUintN(64, message.mintId) !== message.mintId) {
        throw new globalThis.Error("value provided for field message.mintId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.mintId);
    }
    if (message.mint !== "") {
      writer.uint32(18).string(message.mint);
    }
    if (message.walletId !== 0n) {
      if (BigInt.asUintN(64, message.walletId) !== message.walletId) {
        throw new globalThis.Error("value provided for field message.walletId of type uint64 too large");
      }
      writer.uint32(24).uint64(message.walletId);
    }
    if (message.wallet !== "") {
      writer.uint32(34).string(message.wallet);
    }
    if (message.tag !== "") {
      writer.uint32(42).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertWalletTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertWalletTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mintId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.walletId = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.wallet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertWalletTag {
    return {
      mintId: isSet(object.mintId) ? BigInt(object.mintId) : 0n,
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      walletId: isSet(object.walletId) ? BigInt(object.walletId) : 0n,
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: InsertWalletTag): unknown {
    const obj: any = {};
    if (message.mintId !== 0n) {
      obj.mintId = message.mintId.toString();
    }
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.walletId !== 0n) {
      obj.walletId = message.walletId.toString();
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertWalletTag>, I>>(base?: I): InsertWalletTag {
    return InsertWalletTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertWalletTag>, I>>(object: I): InsertWalletTag {
    const message = createBaseInsertWalletTag();
    message.mintId = object.mintId ?? 0n;
    message.mint = object.mint ?? "";
    message.walletId = object.walletId ?? 0n;
    message.wallet = object.wallet ?? "";
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseUpdateWalletStat(): UpdateWalletStat {
  return { walletId: 0n, wallet: "", balance: undefined, txCount: undefined, avgHoldTime: undefined };
}

export const UpdateWalletStat: MessageFns<UpdateWalletStat> = {
  encode(message: UpdateWalletStat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0n) {
      if (BigInt.asUintN(64, message.walletId) !== message.walletId) {
        throw new globalThis.Error("value provided for field message.walletId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    if (message.balance !== undefined) {
      if (BigInt.asUintN(64, message.balance) !== message.balance) {
        throw new globalThis.Error("value provided for field message.balance of type uint64 too large");
      }
      writer.uint32(24).uint64(message.balance);
    }
    if (message.txCount !== undefined) {
      if (BigInt.asUintN(64, message.txCount) !== message.txCount) {
        throw new globalThis.Error("value provided for field message.txCount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.txCount);
    }
    if (message.avgHoldTime !== undefined) {
      writer.uint32(40).uint32(message.avgHoldTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWalletStat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWalletStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.balance = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.txCount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.avgHoldTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWalletStat {
    return {
      walletId: isSet(object.walletId) ? BigInt(object.walletId) : 0n,
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      balance: isSet(object.balance) ? BigInt(object.balance) : undefined,
      txCount: isSet(object.txCount) ? BigInt(object.txCount) : undefined,
      avgHoldTime: isSet(object.avgHoldTime) ? globalThis.Number(object.avgHoldTime) : undefined,
    };
  },

  toJSON(message: UpdateWalletStat): unknown {
    const obj: any = {};
    if (message.walletId !== 0n) {
      obj.walletId = message.walletId.toString();
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.balance !== undefined) {
      obj.balance = message.balance.toString();
    }
    if (message.txCount !== undefined) {
      obj.txCount = message.txCount.toString();
    }
    if (message.avgHoldTime !== undefined) {
      obj.avgHoldTime = Math.round(message.avgHoldTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateWalletStat>, I>>(base?: I): UpdateWalletStat {
    return UpdateWalletStat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateWalletStat>, I>>(object: I): UpdateWalletStat {
    const message = createBaseUpdateWalletStat();
    message.walletId = object.walletId ?? 0n;
    message.wallet = object.wallet ?? "";
    message.balance = object.balance ?? undefined;
    message.txCount = object.txCount ?? undefined;
    message.avgHoldTime = object.avgHoldTime ?? undefined;
    return message;
  },
};

function createBaseSetWalletFundedAt(): SetWalletFundedAt {
  return { walletId: 0n, wallet: "", fundedAt: 0 };
}

export const SetWalletFundedAt: MessageFns<SetWalletFundedAt> = {
  encode(message: SetWalletFundedAt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== 0n) {
      if (BigInt.asUintN(64, message.walletId) !== message.walletId) {
        throw new globalThis.Error("value provided for field message.walletId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    if (message.fundedAt !== 0) {
      writer.uint32(24).uint32(message.fundedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetWalletFundedAt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetWalletFundedAt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.walletId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fundedAt = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetWalletFundedAt {
    return {
      walletId: isSet(object.walletId) ? BigInt(object.walletId) : 0n,
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      fundedAt: isSet(object.fundedAt) ? globalThis.Number(object.fundedAt) : 0,
    };
  },

  toJSON(message: SetWalletFundedAt): unknown {
    const obj: any = {};
    if (message.walletId !== 0n) {
      obj.walletId = message.walletId.toString();
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.fundedAt !== 0) {
      obj.fundedAt = Math.round(message.fundedAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetWalletFundedAt>, I>>(base?: I): SetWalletFundedAt {
    return SetWalletFundedAt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetWalletFundedAt>, I>>(object: I): SetWalletFundedAt {
    const message = createBaseSetWalletFundedAt();
    message.walletId = object.walletId ?? 0n;
    message.wallet = object.wallet ?? "";
    message.fundedAt = object.fundedAt ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
