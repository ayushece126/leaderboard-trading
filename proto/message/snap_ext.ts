// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: message/snap_ext.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "snap_ext";

export interface WalletStatSnap {
  walletAddress: string;
  fundedAt?: number | undefined;
  solBalance?: number | undefined;
  txCount?: bigint | undefined;
  avgHoldTime?: number | undefined;
  globalWalletTags: string[];
}

export interface MintWalletSnap {
  mintAddress: string;
  walletAddress: string;
  poolAddress?: string | undefined;
  holding?: number | undefined;
  buyVolume?: number | undefined;
  sellVolume?: number | undefined;
  buyTokenVolume?: number | undefined;
  sellTokenVolume?: number | undefined;
  buys?: number | undefined;
  sells?: number | undefined;
  realizedPnl?: number | undefined;
  holderSince?: number | undefined;
  walletTag?: string | undefined;
  walletStat?: WalletStatSnap | undefined;
}

export interface Socials {
  twitter?: string | undefined;
  telegram?: string | undefined;
  website?: string | undefined;
}

export interface MintSnapExt {
  mintAddress: string;
  decimals: string;
  name: string;
  symbol: string;
  imageUri?: string | undefined;
  socials?: Socials | undefined;
  totalSupply: number;
  createdAt: bigint;
}

export interface PoolSnapExt {
  poolAddress: string;
  poolTypeDisc: number;
  bondingCurvePct: number;
  liquidity: number;
  mcap: number;
  buyVolume: number;
  buys: number;
  sellVolume: number;
  sells: number;
}

export interface HsItem {
  buy: number;
  holding: number;
  tCount: number;
  cCount: number;
}

export interface HsSnapExt {
  mintAddress: string;
  dev: HsItem | undefined;
  bundle: HsItem | undefined;
  sniper: HsItem | undefined;
  insider: HsItem | undefined;
  sus: HsItem | undefined;
  dBundle: HsItem | undefined;
  term: HsItem | undefined;
  t10: number;
  holders: number;
}

export interface MintPoolSnap {
  mint: MintSnapExt | undefined;
  pool: PoolSnapExt | undefined;
  hs: HsSnapExt | undefined;
}

function createBaseWalletStatSnap(): WalletStatSnap {
  return {
    walletAddress: "",
    fundedAt: undefined,
    solBalance: undefined,
    txCount: undefined,
    avgHoldTime: undefined,
    globalWalletTags: [],
  };
}

export const WalletStatSnap: MessageFns<WalletStatSnap> = {
  encode(message: WalletStatSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletAddress !== "") {
      writer.uint32(10).string(message.walletAddress);
    }
    if (message.fundedAt !== undefined) {
      writer.uint32(24).uint32(message.fundedAt);
    }
    if (message.solBalance !== undefined) {
      writer.uint32(33).double(message.solBalance);
    }
    if (message.txCount !== undefined) {
      if (BigInt.asUintN(64, message.txCount) !== message.txCount) {
        throw new globalThis.Error("value provided for field message.txCount of type uint64 too large");
      }
      writer.uint32(40).uint64(message.txCount);
    }
    if (message.avgHoldTime !== undefined) {
      writer.uint32(48).uint32(message.avgHoldTime);
    }
    for (const v of message.globalWalletTags) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletStatSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletStatSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.walletAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fundedAt = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.solBalance = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.txCount = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.avgHoldTime = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.globalWalletTags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletStatSnap {
    return {
      walletAddress: isSet(object.walletAddress) ? globalThis.String(object.walletAddress) : "",
      fundedAt: isSet(object.fundedAt) ? globalThis.Number(object.fundedAt) : undefined,
      solBalance: isSet(object.solBalance) ? globalThis.Number(object.solBalance) : undefined,
      txCount: isSet(object.txCount) ? BigInt(object.txCount) : undefined,
      avgHoldTime: isSet(object.avgHoldTime) ? globalThis.Number(object.avgHoldTime) : undefined,
      globalWalletTags: globalThis.Array.isArray(object?.globalWalletTags)
        ? object.globalWalletTags.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WalletStatSnap): unknown {
    const obj: any = {};
    if (message.walletAddress !== "") {
      obj.walletAddress = message.walletAddress;
    }
    if (message.fundedAt !== undefined) {
      obj.fundedAt = Math.round(message.fundedAt);
    }
    if (message.solBalance !== undefined) {
      obj.solBalance = message.solBalance;
    }
    if (message.txCount !== undefined) {
      obj.txCount = message.txCount.toString();
    }
    if (message.avgHoldTime !== undefined) {
      obj.avgHoldTime = Math.round(message.avgHoldTime);
    }
    if (message.globalWalletTags?.length) {
      obj.globalWalletTags = message.globalWalletTags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletStatSnap>, I>>(base?: I): WalletStatSnap {
    return WalletStatSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletStatSnap>, I>>(object: I): WalletStatSnap {
    const message = createBaseWalletStatSnap();
    message.walletAddress = object.walletAddress ?? "";
    message.fundedAt = object.fundedAt ?? undefined;
    message.solBalance = object.solBalance ?? undefined;
    message.txCount = object.txCount ?? undefined;
    message.avgHoldTime = object.avgHoldTime ?? undefined;
    message.globalWalletTags = object.globalWalletTags?.map((e) => e) || [];
    return message;
  },
};

function createBaseMintWalletSnap(): MintWalletSnap {
  return {
    mintAddress: "",
    walletAddress: "",
    poolAddress: undefined,
    holding: undefined,
    buyVolume: undefined,
    sellVolume: undefined,
    buyTokenVolume: undefined,
    sellTokenVolume: undefined,
    buys: undefined,
    sells: undefined,
    realizedPnl: undefined,
    holderSince: undefined,
    walletTag: undefined,
    walletStat: undefined,
  };
}

export const MintWalletSnap: MessageFns<MintWalletSnap> = {
  encode(message: MintWalletSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mintAddress !== "") {
      writer.uint32(10).string(message.mintAddress);
    }
    if (message.walletAddress !== "") {
      writer.uint32(18).string(message.walletAddress);
    }
    if (message.poolAddress !== undefined) {
      writer.uint32(26).string(message.poolAddress);
    }
    if (message.holding !== undefined) {
      writer.uint32(33).double(message.holding);
    }
    if (message.buyVolume !== undefined) {
      writer.uint32(41).double(message.buyVolume);
    }
    if (message.sellVolume !== undefined) {
      writer.uint32(49).double(message.sellVolume);
    }
    if (message.buyTokenVolume !== undefined) {
      writer.uint32(57).double(message.buyTokenVolume);
    }
    if (message.sellTokenVolume !== undefined) {
      writer.uint32(65).double(message.sellTokenVolume);
    }
    if (message.buys !== undefined) {
      writer.uint32(72).uint32(message.buys);
    }
    if (message.sells !== undefined) {
      writer.uint32(80).uint32(message.sells);
    }
    if (message.realizedPnl !== undefined) {
      writer.uint32(89).double(message.realizedPnl);
    }
    if (message.holderSince !== undefined) {
      writer.uint32(96).uint32(message.holderSince);
    }
    if (message.walletTag !== undefined) {
      writer.uint32(106).string(message.walletTag);
    }
    if (message.walletStat !== undefined) {
      WalletStatSnap.encode(message.walletStat, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintWalletSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintWalletSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mintAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.walletAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.poolAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.holding = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.buyVolume = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.sellVolume = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.buyTokenVolume = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.sellTokenVolume = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.buys = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sells = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.realizedPnl = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.holderSince = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.walletTag = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.walletStat = WalletStatSnap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintWalletSnap {
    return {
      mintAddress: isSet(object.mintAddress) ? globalThis.String(object.mintAddress) : "",
      walletAddress: isSet(object.walletAddress) ? globalThis.String(object.walletAddress) : "",
      poolAddress: isSet(object.poolAddress) ? globalThis.String(object.poolAddress) : undefined,
      holding: isSet(object.holding) ? globalThis.Number(object.holding) : undefined,
      buyVolume: isSet(object.buyVolume) ? globalThis.Number(object.buyVolume) : undefined,
      sellVolume: isSet(object.sellVolume) ? globalThis.Number(object.sellVolume) : undefined,
      buyTokenVolume: isSet(object.buyTokenVolume) ? globalThis.Number(object.buyTokenVolume) : undefined,
      sellTokenVolume: isSet(object.sellTokenVolume) ? globalThis.Number(object.sellTokenVolume) : undefined,
      buys: isSet(object.buys) ? globalThis.Number(object.buys) : undefined,
      sells: isSet(object.sells) ? globalThis.Number(object.sells) : undefined,
      realizedPnl: isSet(object.realizedPnl) ? globalThis.Number(object.realizedPnl) : undefined,
      holderSince: isSet(object.holderSince) ? globalThis.Number(object.holderSince) : undefined,
      walletTag: isSet(object.walletTag) ? globalThis.String(object.walletTag) : undefined,
      walletStat: isSet(object.walletStat) ? WalletStatSnap.fromJSON(object.walletStat) : undefined,
    };
  },

  toJSON(message: MintWalletSnap): unknown {
    const obj: any = {};
    if (message.mintAddress !== "") {
      obj.mintAddress = message.mintAddress;
    }
    if (message.walletAddress !== "") {
      obj.walletAddress = message.walletAddress;
    }
    if (message.poolAddress !== undefined) {
      obj.poolAddress = message.poolAddress;
    }
    if (message.holding !== undefined) {
      obj.holding = message.holding;
    }
    if (message.buyVolume !== undefined) {
      obj.buyVolume = message.buyVolume;
    }
    if (message.sellVolume !== undefined) {
      obj.sellVolume = message.sellVolume;
    }
    if (message.buyTokenVolume !== undefined) {
      obj.buyTokenVolume = message.buyTokenVolume;
    }
    if (message.sellTokenVolume !== undefined) {
      obj.sellTokenVolume = message.sellTokenVolume;
    }
    if (message.buys !== undefined) {
      obj.buys = Math.round(message.buys);
    }
    if (message.sells !== undefined) {
      obj.sells = Math.round(message.sells);
    }
    if (message.realizedPnl !== undefined) {
      obj.realizedPnl = message.realizedPnl;
    }
    if (message.holderSince !== undefined) {
      obj.holderSince = Math.round(message.holderSince);
    }
    if (message.walletTag !== undefined) {
      obj.walletTag = message.walletTag;
    }
    if (message.walletStat !== undefined) {
      obj.walletStat = WalletStatSnap.toJSON(message.walletStat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintWalletSnap>, I>>(base?: I): MintWalletSnap {
    return MintWalletSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintWalletSnap>, I>>(object: I): MintWalletSnap {
    const message = createBaseMintWalletSnap();
    message.mintAddress = object.mintAddress ?? "";
    message.walletAddress = object.walletAddress ?? "";
    message.poolAddress = object.poolAddress ?? undefined;
    message.holding = object.holding ?? undefined;
    message.buyVolume = object.buyVolume ?? undefined;
    message.sellVolume = object.sellVolume ?? undefined;
    message.buyTokenVolume = object.buyTokenVolume ?? undefined;
    message.sellTokenVolume = object.sellTokenVolume ?? undefined;
    message.buys = object.buys ?? undefined;
    message.sells = object.sells ?? undefined;
    message.realizedPnl = object.realizedPnl ?? undefined;
    message.holderSince = object.holderSince ?? undefined;
    message.walletTag = object.walletTag ?? undefined;
    message.walletStat = (object.walletStat !== undefined && object.walletStat !== null)
      ? WalletStatSnap.fromPartial(object.walletStat)
      : undefined;
    return message;
  },
};

function createBaseSocials(): Socials {
  return { twitter: undefined, telegram: undefined, website: undefined };
}

export const Socials: MessageFns<Socials> = {
  encode(message: Socials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.twitter !== undefined) {
      writer.uint32(10).string(message.twitter);
    }
    if (message.telegram !== undefined) {
      writer.uint32(18).string(message.telegram);
    }
    if (message.website !== undefined) {
      writer.uint32(26).string(message.website);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Socials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.twitter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telegram = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.website = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Socials {
    return {
      twitter: isSet(object.twitter) ? globalThis.String(object.twitter) : undefined,
      telegram: isSet(object.telegram) ? globalThis.String(object.telegram) : undefined,
      website: isSet(object.website) ? globalThis.String(object.website) : undefined,
    };
  },

  toJSON(message: Socials): unknown {
    const obj: any = {};
    if (message.twitter !== undefined) {
      obj.twitter = message.twitter;
    }
    if (message.telegram !== undefined) {
      obj.telegram = message.telegram;
    }
    if (message.website !== undefined) {
      obj.website = message.website;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Socials>, I>>(base?: I): Socials {
    return Socials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Socials>, I>>(object: I): Socials {
    const message = createBaseSocials();
    message.twitter = object.twitter ?? undefined;
    message.telegram = object.telegram ?? undefined;
    message.website = object.website ?? undefined;
    return message;
  },
};

function createBaseMintSnapExt(): MintSnapExt {
  return {
    mintAddress: "",
    decimals: "",
    name: "",
    symbol: "",
    imageUri: undefined,
    socials: undefined,
    totalSupply: 0,
    createdAt: 0n,
  };
}

export const MintSnapExt: MessageFns<MintSnapExt> = {
  encode(message: MintSnapExt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mintAddress !== "") {
      writer.uint32(10).string(message.mintAddress);
    }
    if (message.decimals !== "") {
      writer.uint32(18).string(message.decimals);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.imageUri !== undefined) {
      writer.uint32(42).string(message.imageUri);
    }
    if (message.socials !== undefined) {
      Socials.encode(message.socials, writer.uint32(50).fork()).join();
    }
    if (message.totalSupply !== 0) {
      writer.uint32(57).double(message.totalSupply);
    }
    if (message.createdAt !== 0n) {
      if (BigInt.asIntN(64, message.createdAt) !== message.createdAt) {
        throw new globalThis.Error("value provided for field message.createdAt of type int64 too large");
      }
      writer.uint32(64).int64(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintSnapExt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintSnapExt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mintAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.decimals = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.socials = Socials.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.totalSupply = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintSnapExt {
    return {
      mintAddress: isSet(object.mintAddress) ? globalThis.String(object.mintAddress) : "",
      decimals: isSet(object.decimals) ? globalThis.String(object.decimals) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : undefined,
      socials: isSet(object.socials) ? Socials.fromJSON(object.socials) : undefined,
      totalSupply: isSet(object.totalSupply) ? globalThis.Number(object.totalSupply) : 0,
      createdAt: isSet(object.createdAt) ? BigInt(object.createdAt) : 0n,
    };
  },

  toJSON(message: MintSnapExt): unknown {
    const obj: any = {};
    if (message.mintAddress !== "") {
      obj.mintAddress = message.mintAddress;
    }
    if (message.decimals !== "") {
      obj.decimals = message.decimals;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.socials !== undefined) {
      obj.socials = Socials.toJSON(message.socials);
    }
    if (message.totalSupply !== 0) {
      obj.totalSupply = message.totalSupply;
    }
    if (message.createdAt !== 0n) {
      obj.createdAt = message.createdAt.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintSnapExt>, I>>(base?: I): MintSnapExt {
    return MintSnapExt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintSnapExt>, I>>(object: I): MintSnapExt {
    const message = createBaseMintSnapExt();
    message.mintAddress = object.mintAddress ?? "";
    message.decimals = object.decimals ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.imageUri = object.imageUri ?? undefined;
    message.socials = (object.socials !== undefined && object.socials !== null)
      ? Socials.fromPartial(object.socials)
      : undefined;
    message.totalSupply = object.totalSupply ?? 0;
    message.createdAt = object.createdAt ?? 0n;
    return message;
  },
};

function createBasePoolSnapExt(): PoolSnapExt {
  return {
    poolAddress: "",
    poolTypeDisc: 0,
    bondingCurvePct: 0,
    liquidity: 0,
    mcap: 0,
    buyVolume: 0,
    buys: 0,
    sellVolume: 0,
    sells: 0,
  };
}

export const PoolSnapExt: MessageFns<PoolSnapExt> = {
  encode(message: PoolSnapExt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.poolAddress !== "") {
      writer.uint32(10).string(message.poolAddress);
    }
    if (message.poolTypeDisc !== 0) {
      writer.uint32(16).uint32(message.poolTypeDisc);
    }
    if (message.bondingCurvePct !== 0) {
      writer.uint32(29).float(message.bondingCurvePct);
    }
    if (message.liquidity !== 0) {
      writer.uint32(33).double(message.liquidity);
    }
    if (message.mcap !== 0) {
      writer.uint32(41).double(message.mcap);
    }
    if (message.buyVolume !== 0) {
      writer.uint32(49).double(message.buyVolume);
    }
    if (message.buys !== 0) {
      writer.uint32(56).uint32(message.buys);
    }
    if (message.sellVolume !== 0) {
      writer.uint32(65).double(message.sellVolume);
    }
    if (message.sells !== 0) {
      writer.uint32(72).uint32(message.sells);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PoolSnapExt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoolSnapExt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.poolAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.poolTypeDisc = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.bondingCurvePct = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.liquidity = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.mcap = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.buyVolume = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.buys = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.sellVolume = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sells = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PoolSnapExt {
    return {
      poolAddress: isSet(object.poolAddress) ? globalThis.String(object.poolAddress) : "",
      poolTypeDisc: isSet(object.poolTypeDisc) ? globalThis.Number(object.poolTypeDisc) : 0,
      bondingCurvePct: isSet(object.bondingCurvePct) ? globalThis.Number(object.bondingCurvePct) : 0,
      liquidity: isSet(object.liquidity) ? globalThis.Number(object.liquidity) : 0,
      mcap: isSet(object.mcap) ? globalThis.Number(object.mcap) : 0,
      buyVolume: isSet(object.buyVolume) ? globalThis.Number(object.buyVolume) : 0,
      buys: isSet(object.buys) ? globalThis.Number(object.buys) : 0,
      sellVolume: isSet(object.sellVolume) ? globalThis.Number(object.sellVolume) : 0,
      sells: isSet(object.sells) ? globalThis.Number(object.sells) : 0,
    };
  },

  toJSON(message: PoolSnapExt): unknown {
    const obj: any = {};
    if (message.poolAddress !== "") {
      obj.poolAddress = message.poolAddress;
    }
    if (message.poolTypeDisc !== 0) {
      obj.poolTypeDisc = Math.round(message.poolTypeDisc);
    }
    if (message.bondingCurvePct !== 0) {
      obj.bondingCurvePct = message.bondingCurvePct;
    }
    if (message.liquidity !== 0) {
      obj.liquidity = message.liquidity;
    }
    if (message.mcap !== 0) {
      obj.mcap = message.mcap;
    }
    if (message.buyVolume !== 0) {
      obj.buyVolume = message.buyVolume;
    }
    if (message.buys !== 0) {
      obj.buys = Math.round(message.buys);
    }
    if (message.sellVolume !== 0) {
      obj.sellVolume = message.sellVolume;
    }
    if (message.sells !== 0) {
      obj.sells = Math.round(message.sells);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PoolSnapExt>, I>>(base?: I): PoolSnapExt {
    return PoolSnapExt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PoolSnapExt>, I>>(object: I): PoolSnapExt {
    const message = createBasePoolSnapExt();
    message.poolAddress = object.poolAddress ?? "";
    message.poolTypeDisc = object.poolTypeDisc ?? 0;
    message.bondingCurvePct = object.bondingCurvePct ?? 0;
    message.liquidity = object.liquidity ?? 0;
    message.mcap = object.mcap ?? 0;
    message.buyVolume = object.buyVolume ?? 0;
    message.buys = object.buys ?? 0;
    message.sellVolume = object.sellVolume ?? 0;
    message.sells = object.sells ?? 0;
    return message;
  },
};

function createBaseHsItem(): HsItem {
  return { buy: 0, holding: 0, tCount: 0, cCount: 0 };
}

export const HsItem: MessageFns<HsItem> = {
  encode(message: HsItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buy !== 0) {
      writer.uint32(9).double(message.buy);
    }
    if (message.holding !== 0) {
      writer.uint32(17).double(message.holding);
    }
    if (message.tCount !== 0) {
      writer.uint32(24).uint32(message.tCount);
    }
    if (message.cCount !== 0) {
      writer.uint32(32).uint32(message.cCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HsItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.buy = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.holding = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tCount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HsItem {
    return {
      buy: isSet(object.buy) ? globalThis.Number(object.buy) : 0,
      holding: isSet(object.holding) ? globalThis.Number(object.holding) : 0,
      tCount: isSet(object.tCount) ? globalThis.Number(object.tCount) : 0,
      cCount: isSet(object.cCount) ? globalThis.Number(object.cCount) : 0,
    };
  },

  toJSON(message: HsItem): unknown {
    const obj: any = {};
    if (message.buy !== 0) {
      obj.buy = message.buy;
    }
    if (message.holding !== 0) {
      obj.holding = message.holding;
    }
    if (message.tCount !== 0) {
      obj.tCount = Math.round(message.tCount);
    }
    if (message.cCount !== 0) {
      obj.cCount = Math.round(message.cCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HsItem>, I>>(base?: I): HsItem {
    return HsItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HsItem>, I>>(object: I): HsItem {
    const message = createBaseHsItem();
    message.buy = object.buy ?? 0;
    message.holding = object.holding ?? 0;
    message.tCount = object.tCount ?? 0;
    message.cCount = object.cCount ?? 0;
    return message;
  },
};

function createBaseHsSnapExt(): HsSnapExt {
  return {
    mintAddress: "",
    dev: undefined,
    bundle: undefined,
    sniper: undefined,
    insider: undefined,
    sus: undefined,
    dBundle: undefined,
    term: undefined,
    t10: 0,
    holders: 0,
  };
}

export const HsSnapExt: MessageFns<HsSnapExt> = {
  encode(message: HsSnapExt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mintAddress !== "") {
      writer.uint32(10).string(message.mintAddress);
    }
    if (message.dev !== undefined) {
      HsItem.encode(message.dev, writer.uint32(18).fork()).join();
    }
    if (message.bundle !== undefined) {
      HsItem.encode(message.bundle, writer.uint32(26).fork()).join();
    }
    if (message.sniper !== undefined) {
      HsItem.encode(message.sniper, writer.uint32(34).fork()).join();
    }
    if (message.insider !== undefined) {
      HsItem.encode(message.insider, writer.uint32(42).fork()).join();
    }
    if (message.sus !== undefined) {
      HsItem.encode(message.sus, writer.uint32(50).fork()).join();
    }
    if (message.dBundle !== undefined) {
      HsItem.encode(message.dBundle, writer.uint32(58).fork()).join();
    }
    if (message.term !== undefined) {
      HsItem.encode(message.term, writer.uint32(66).fork()).join();
    }
    if (message.t10 !== 0) {
      writer.uint32(73).double(message.t10);
    }
    if (message.holders !== 0) {
      writer.uint32(80).uint32(message.holders);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HsSnapExt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHsSnapExt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mintAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dev = HsItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bundle = HsItem.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sniper = HsItem.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.insider = HsItem.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sus = HsItem.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dBundle = HsItem.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.term = HsItem.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.t10 = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.holders = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HsSnapExt {
    return {
      mintAddress: isSet(object.mintAddress) ? globalThis.String(object.mintAddress) : "",
      dev: isSet(object.dev) ? HsItem.fromJSON(object.dev) : undefined,
      bundle: isSet(object.bundle) ? HsItem.fromJSON(object.bundle) : undefined,
      sniper: isSet(object.sniper) ? HsItem.fromJSON(object.sniper) : undefined,
      insider: isSet(object.insider) ? HsItem.fromJSON(object.insider) : undefined,
      sus: isSet(object.sus) ? HsItem.fromJSON(object.sus) : undefined,
      dBundle: isSet(object.dBundle) ? HsItem.fromJSON(object.dBundle) : undefined,
      term: isSet(object.term) ? HsItem.fromJSON(object.term) : undefined,
      t10: isSet(object.t10) ? globalThis.Number(object.t10) : 0,
      holders: isSet(object.holders) ? globalThis.Number(object.holders) : 0,
    };
  },

  toJSON(message: HsSnapExt): unknown {
    const obj: any = {};
    if (message.mintAddress !== "") {
      obj.mintAddress = message.mintAddress;
    }
    if (message.dev !== undefined) {
      obj.dev = HsItem.toJSON(message.dev);
    }
    if (message.bundle !== undefined) {
      obj.bundle = HsItem.toJSON(message.bundle);
    }
    if (message.sniper !== undefined) {
      obj.sniper = HsItem.toJSON(message.sniper);
    }
    if (message.insider !== undefined) {
      obj.insider = HsItem.toJSON(message.insider);
    }
    if (message.sus !== undefined) {
      obj.sus = HsItem.toJSON(message.sus);
    }
    if (message.dBundle !== undefined) {
      obj.dBundle = HsItem.toJSON(message.dBundle);
    }
    if (message.term !== undefined) {
      obj.term = HsItem.toJSON(message.term);
    }
    if (message.t10 !== 0) {
      obj.t10 = message.t10;
    }
    if (message.holders !== 0) {
      obj.holders = Math.round(message.holders);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HsSnapExt>, I>>(base?: I): HsSnapExt {
    return HsSnapExt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HsSnapExt>, I>>(object: I): HsSnapExt {
    const message = createBaseHsSnapExt();
    message.mintAddress = object.mintAddress ?? "";
    message.dev = (object.dev !== undefined && object.dev !== null) ? HsItem.fromPartial(object.dev) : undefined;
    message.bundle = (object.bundle !== undefined && object.bundle !== null)
      ? HsItem.fromPartial(object.bundle)
      : undefined;
    message.sniper = (object.sniper !== undefined && object.sniper !== null)
      ? HsItem.fromPartial(object.sniper)
      : undefined;
    message.insider = (object.insider !== undefined && object.insider !== null)
      ? HsItem.fromPartial(object.insider)
      : undefined;
    message.sus = (object.sus !== undefined && object.sus !== null) ? HsItem.fromPartial(object.sus) : undefined;
    message.dBundle = (object.dBundle !== undefined && object.dBundle !== null)
      ? HsItem.fromPartial(object.dBundle)
      : undefined;
    message.term = (object.term !== undefined && object.term !== null) ? HsItem.fromPartial(object.term) : undefined;
    message.t10 = object.t10 ?? 0;
    message.holders = object.holders ?? 0;
    return message;
  },
};

function createBaseMintPoolSnap(): MintPoolSnap {
  return { mint: undefined, pool: undefined, hs: undefined };
}

export const MintPoolSnap: MessageFns<MintPoolSnap> = {
  encode(message: MintPoolSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== undefined) {
      MintSnapExt.encode(message.mint, writer.uint32(10).fork()).join();
    }
    if (message.pool !== undefined) {
      PoolSnapExt.encode(message.pool, writer.uint32(18).fork()).join();
    }
    if (message.hs !== undefined) {
      HsSnapExt.encode(message.hs, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintPoolSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintPoolSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = MintSnapExt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pool = PoolSnapExt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hs = HsSnapExt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintPoolSnap {
    return {
      mint: isSet(object.mint) ? MintSnapExt.fromJSON(object.mint) : undefined,
      pool: isSet(object.pool) ? PoolSnapExt.fromJSON(object.pool) : undefined,
      hs: isSet(object.hs) ? HsSnapExt.fromJSON(object.hs) : undefined,
    };
  },

  toJSON(message: MintPoolSnap): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = MintSnapExt.toJSON(message.mint);
    }
    if (message.pool !== undefined) {
      obj.pool = PoolSnapExt.toJSON(message.pool);
    }
    if (message.hs !== undefined) {
      obj.hs = HsSnapExt.toJSON(message.hs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintPoolSnap>, I>>(base?: I): MintPoolSnap {
    return MintPoolSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintPoolSnap>, I>>(object: I): MintPoolSnap {
    const message = createBaseMintPoolSnap();
    message.mint = (object.mint !== undefined && object.mint !== null)
      ? MintSnapExt.fromPartial(object.mint)
      : undefined;
    message.pool = (object.pool !== undefined && object.pool !== null)
      ? PoolSnapExt.fromPartial(object.pool)
      : undefined;
    message.hs = (object.hs !== undefined && object.hs !== null) ? HsSnapExt.fromPartial(object.hs) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
