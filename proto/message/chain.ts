// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: message/chain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "chain";

export interface BlockMeta {
  slot: bigint;
  timestamp: bigint;
}

export interface Transaction {
  signature: string;
  slot: bigint;
  signers: string[];
  timestamp: bigint;
  isBackrun: boolean;
}

export interface SolTransfer {
  sender: string;
  receiver: string;
  lamports: bigint;
  isNewReceiver: boolean;
}

export interface SolBalanceChange {
  account: string;
  pre: bigint;
  post: bigint;
}

export interface SplTransfer {
  mint?: string | undefined;
  sender: string;
  senderAuthority: string;
  receiver: string;
  receiverAuthority: string;
  amount: bigint;
  isNewReceiver: boolean;
}

export interface SplBalanceChange {
  mint: string;
  owner: string;
  pre: bigint;
  post: bigint;
}

export interface SplInitialize {
  mint: string;
  decimals: number;
  mintAuthority?: string | undefined;
  freezeAuthority?: string | undefined;
}

export interface SplMintTo {
  mint: string;
  amount: bigint;
}

export interface SplBurn {
  mint: string;
  amount: bigint;
}

export interface MplCreateMetadataV3 {
  mint: string;
  name: string;
  symbol: string;
  uri: string;
}

export interface SplSetAuthority {
  mint: string;
  authorityType: number;
  newAuthority?: string | undefined;
}

export interface PumpfunCreate {
  name: string;
  symbol: string;
  uri: string;
  mint: string;
  bondingCurve: string;
  creator: string;
}

export interface PumpfunTrade {
  mint: string;
  bondingCurve: string;
  solAmount: bigint;
  tokenAmount: bigint;
  direction: number;
  user: string;
  virtualSolReserve: bigint;
  virtualTokenReserve: bigint;
}

export interface PumpfunComplete {
  mint: string;
  bondingCurve: string;
}

export interface OpenbookInitializeMarket {
  market: string;
  baseMint: string;
  quoteMint: string;
  requestQueue: string;
  eventQueue: string;
  bids: string;
  asks: string;
  baseVault: string;
  quoteVault: string;
}

export interface RaydiumInitialize {
  baseMint: string;
  quoteMint: string;
  ammId: string;
  lpMint: string;
  market: string;
  creator: string;
  openTime: bigint;
  baseReserve: bigint;
  quoteReserve: bigint;
}

export interface RaydiumDeposit {
  ammId: string;
  lpMint: string;
  user: string;
  baseAmount: bigint;
  quoteAmount: bigint;
  baseReserve: bigint;
  quoteReserve: bigint;
}

export interface RaydiumWithdraw {
  ammId: string;
  lpMint: string;
  user: string;
  lpAmount: bigint;
  baseAmount: bigint;
  quoteAmount: bigint;
  baseReserve: bigint;
  quoteReserve: bigint;
}

export interface RaydiumSwap {
  ammId: string;
  user: string;
  direction: number;
  baseAmount: bigint;
  quoteAmount: bigint;
  baseReserve: bigint;
  quoteReserve: bigint;
}

function createBaseBlockMeta(): BlockMeta {
  return { slot: 0n, timestamp: 0n };
}

export const BlockMeta: MessageFns<BlockMeta> = {
  encode(message: BlockMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slot !== 0n) {
      if (BigInt.asUintN(64, message.slot) !== message.slot) {
        throw new globalThis.Error("value provided for field message.slot of type uint64 too large");
      }
      writer.uint32(8).uint64(message.slot);
    }
    if (message.timestamp !== 0n) {
      if (BigInt.asUintN(64, message.timestamp) !== message.timestamp) {
        throw new globalThis.Error("value provided for field message.timestamp of type uint64 too large");
      }
      writer.uint32(16).uint64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slot = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockMeta {
    return {
      slot: isSet(object.slot) ? BigInt(object.slot) : 0n,
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp) : 0n,
    };
  },

  toJSON(message: BlockMeta): unknown {
    const obj: any = {};
    if (message.slot !== 0n) {
      obj.slot = message.slot.toString();
    }
    if (message.timestamp !== 0n) {
      obj.timestamp = message.timestamp.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockMeta>, I>>(base?: I): BlockMeta {
    return BlockMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockMeta>, I>>(object: I): BlockMeta {
    const message = createBaseBlockMeta();
    message.slot = object.slot ?? 0n;
    message.timestamp = object.timestamp ?? 0n;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { signature: "", slot: 0n, signers: [], timestamp: 0n, isBackrun: false };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.slot !== 0n) {
      if (BigInt.asUintN(64, message.slot) !== message.slot) {
        throw new globalThis.Error("value provided for field message.slot of type uint64 too large");
      }
      writer.uint32(16).uint64(message.slot);
    }
    for (const v of message.signers) {
      writer.uint32(26).string(v!);
    }
    if (message.timestamp !== 0n) {
      if (BigInt.asUintN(64, message.timestamp) !== message.timestamp) {
        throw new globalThis.Error("value provided for field message.timestamp of type uint64 too large");
      }
      writer.uint32(32).uint64(message.timestamp);
    }
    if (message.isBackrun !== false) {
      writer.uint32(40).bool(message.isBackrun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slot = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signers.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isBackrun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      slot: isSet(object.slot) ? BigInt(object.slot) : 0n,
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => globalThis.String(e)) : [],
      timestamp: isSet(object.timestamp) ? BigInt(object.timestamp) : 0n,
      isBackrun: isSet(object.isBackrun) ? globalThis.Boolean(object.isBackrun) : false,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.slot !== 0n) {
      obj.slot = message.slot.toString();
    }
    if (message.signers?.length) {
      obj.signers = message.signers;
    }
    if (message.timestamp !== 0n) {
      obj.timestamp = message.timestamp.toString();
    }
    if (message.isBackrun !== false) {
      obj.isBackrun = message.isBackrun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.signature = object.signature ?? "";
    message.slot = object.slot ?? 0n;
    message.signers = object.signers?.map((e) => e) || [];
    message.timestamp = object.timestamp ?? 0n;
    message.isBackrun = object.isBackrun ?? false;
    return message;
  },
};

function createBaseSolTransfer(): SolTransfer {
  return { sender: "", receiver: "", lamports: 0n, isNewReceiver: false };
}

export const SolTransfer: MessageFns<SolTransfer> = {
  encode(message: SolTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.receiver !== "") {
      writer.uint32(18).string(message.receiver);
    }
    if (message.lamports !== 0n) {
      if (BigInt.asUintN(64, message.lamports) !== message.lamports) {
        throw new globalThis.Error("value provided for field message.lamports of type uint64 too large");
      }
      writer.uint32(24).uint64(message.lamports);
    }
    if (message.isNewReceiver !== false) {
      writer.uint32(32).bool(message.isNewReceiver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receiver = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lamports = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isNewReceiver = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolTransfer {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      lamports: isSet(object.lamports) ? BigInt(object.lamports) : 0n,
      isNewReceiver: isSet(object.isNewReceiver) ? globalThis.Boolean(object.isNewReceiver) : false,
    };
  },

  toJSON(message: SolTransfer): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.lamports !== 0n) {
      obj.lamports = message.lamports.toString();
    }
    if (message.isNewReceiver !== false) {
      obj.isNewReceiver = message.isNewReceiver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolTransfer>, I>>(base?: I): SolTransfer {
    return SolTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolTransfer>, I>>(object: I): SolTransfer {
    const message = createBaseSolTransfer();
    message.sender = object.sender ?? "";
    message.receiver = object.receiver ?? "";
    message.lamports = object.lamports ?? 0n;
    message.isNewReceiver = object.isNewReceiver ?? false;
    return message;
  },
};

function createBaseSolBalanceChange(): SolBalanceChange {
  return { account: "", pre: 0n, post: 0n };
}

export const SolBalanceChange: MessageFns<SolBalanceChange> = {
  encode(message: SolBalanceChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.pre !== 0n) {
      if (BigInt.asUintN(64, message.pre) !== message.pre) {
        throw new globalThis.Error("value provided for field message.pre of type uint64 too large");
      }
      writer.uint32(16).uint64(message.pre);
    }
    if (message.post !== 0n) {
      if (BigInt.asUintN(64, message.post) !== message.post) {
        throw new globalThis.Error("value provided for field message.post of type uint64 too large");
      }
      writer.uint32(24).uint64(message.post);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SolBalanceChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolBalanceChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pre = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.post = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolBalanceChange {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      pre: isSet(object.pre) ? BigInt(object.pre) : 0n,
      post: isSet(object.post) ? BigInt(object.post) : 0n,
    };
  },

  toJSON(message: SolBalanceChange): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.pre !== 0n) {
      obj.pre = message.pre.toString();
    }
    if (message.post !== 0n) {
      obj.post = message.post.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolBalanceChange>, I>>(base?: I): SolBalanceChange {
    return SolBalanceChange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolBalanceChange>, I>>(object: I): SolBalanceChange {
    const message = createBaseSolBalanceChange();
    message.account = object.account ?? "";
    message.pre = object.pre ?? 0n;
    message.post = object.post ?? 0n;
    return message;
  },
};

function createBaseSplTransfer(): SplTransfer {
  return {
    mint: undefined,
    sender: "",
    senderAuthority: "",
    receiver: "",
    receiverAuthority: "",
    amount: 0n,
    isNewReceiver: false,
  };
}

export const SplTransfer: MessageFns<SplTransfer> = {
  encode(message: SplTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== undefined) {
      writer.uint32(10).string(message.mint);
    }
    if (message.sender !== "") {
      writer.uint32(18).string(message.sender);
    }
    if (message.senderAuthority !== "") {
      writer.uint32(26).string(message.senderAuthority);
    }
    if (message.receiver !== "") {
      writer.uint32(34).string(message.receiver);
    }
    if (message.receiverAuthority !== "") {
      writer.uint32(42).string(message.receiverAuthority);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(48).uint64(message.amount);
    }
    if (message.isNewReceiver !== false) {
      writer.uint32(56).bool(message.isNewReceiver);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.senderAuthority = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiver = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.receiverAuthority = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isNewReceiver = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplTransfer {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : undefined,
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      senderAuthority: isSet(object.senderAuthority) ? globalThis.String(object.senderAuthority) : "",
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      receiverAuthority: isSet(object.receiverAuthority) ? globalThis.String(object.receiverAuthority) : "",
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
      isNewReceiver: isSet(object.isNewReceiver) ? globalThis.Boolean(object.isNewReceiver) : false,
    };
  },

  toJSON(message: SplTransfer): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.senderAuthority !== "") {
      obj.senderAuthority = message.senderAuthority;
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.receiverAuthority !== "") {
      obj.receiverAuthority = message.receiverAuthority;
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    if (message.isNewReceiver !== false) {
      obj.isNewReceiver = message.isNewReceiver;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplTransfer>, I>>(base?: I): SplTransfer {
    return SplTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplTransfer>, I>>(object: I): SplTransfer {
    const message = createBaseSplTransfer();
    message.mint = object.mint ?? undefined;
    message.sender = object.sender ?? "";
    message.senderAuthority = object.senderAuthority ?? "";
    message.receiver = object.receiver ?? "";
    message.receiverAuthority = object.receiverAuthority ?? "";
    message.amount = object.amount ?? 0n;
    message.isNewReceiver = object.isNewReceiver ?? false;
    return message;
  },
};

function createBaseSplBalanceChange(): SplBalanceChange {
  return { mint: "", owner: "", pre: 0n, post: 0n };
}

export const SplBalanceChange: MessageFns<SplBalanceChange> = {
  encode(message: SplBalanceChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.pre !== 0n) {
      if (BigInt.asUintN(64, message.pre) !== message.pre) {
        throw new globalThis.Error("value provided for field message.pre of type uint64 too large");
      }
      writer.uint32(24).uint64(message.pre);
    }
    if (message.post !== 0n) {
      if (BigInt.asUintN(64, message.post) !== message.post) {
        throw new globalThis.Error("value provided for field message.post of type uint64 too large");
      }
      writer.uint32(32).uint64(message.post);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplBalanceChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplBalanceChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pre = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.post = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplBalanceChange {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      pre: isSet(object.pre) ? BigInt(object.pre) : 0n,
      post: isSet(object.post) ? BigInt(object.post) : 0n,
    };
  },

  toJSON(message: SplBalanceChange): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.pre !== 0n) {
      obj.pre = message.pre.toString();
    }
    if (message.post !== 0n) {
      obj.post = message.post.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplBalanceChange>, I>>(base?: I): SplBalanceChange {
    return SplBalanceChange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplBalanceChange>, I>>(object: I): SplBalanceChange {
    const message = createBaseSplBalanceChange();
    message.mint = object.mint ?? "";
    message.owner = object.owner ?? "";
    message.pre = object.pre ?? 0n;
    message.post = object.post ?? 0n;
    return message;
  },
};

function createBaseSplInitialize(): SplInitialize {
  return { mint: "", decimals: 0, mintAuthority: undefined, freezeAuthority: undefined };
}

export const SplInitialize: MessageFns<SplInitialize> = {
  encode(message: SplInitialize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.decimals !== 0) {
      writer.uint32(16).uint32(message.decimals);
    }
    if (message.mintAuthority !== undefined) {
      writer.uint32(26).string(message.mintAuthority);
    }
    if (message.freezeAuthority !== undefined) {
      writer.uint32(34).string(message.freezeAuthority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplInitialize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplInitialize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mintAuthority = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.freezeAuthority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplInitialize {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      mintAuthority: isSet(object.mintAuthority) ? globalThis.String(object.mintAuthority) : undefined,
      freezeAuthority: isSet(object.freezeAuthority) ? globalThis.String(object.freezeAuthority) : undefined,
    };
  },

  toJSON(message: SplInitialize): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.mintAuthority !== undefined) {
      obj.mintAuthority = message.mintAuthority;
    }
    if (message.freezeAuthority !== undefined) {
      obj.freezeAuthority = message.freezeAuthority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplInitialize>, I>>(base?: I): SplInitialize {
    return SplInitialize.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplInitialize>, I>>(object: I): SplInitialize {
    const message = createBaseSplInitialize();
    message.mint = object.mint ?? "";
    message.decimals = object.decimals ?? 0;
    message.mintAuthority = object.mintAuthority ?? undefined;
    message.freezeAuthority = object.freezeAuthority ?? undefined;
    return message;
  },
};

function createBaseSplMintTo(): SplMintTo {
  return { mint: "", amount: 0n };
}

export const SplMintTo: MessageFns<SplMintTo> = {
  encode(message: SplMintTo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplMintTo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplMintTo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplMintTo {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
    };
  },

  toJSON(message: SplMintTo): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplMintTo>, I>>(base?: I): SplMintTo {
    return SplMintTo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplMintTo>, I>>(object: I): SplMintTo {
    const message = createBaseSplMintTo();
    message.mint = object.mint ?? "";
    message.amount = object.amount ?? 0n;
    return message;
  },
};

function createBaseSplBurn(): SplBurn {
  return { mint: "", amount: 0n };
}

export const SplBurn: MessageFns<SplBurn> = {
  encode(message: SplBurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplBurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplBurn {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
    };
  },

  toJSON(message: SplBurn): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplBurn>, I>>(base?: I): SplBurn {
    return SplBurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplBurn>, I>>(object: I): SplBurn {
    const message = createBaseSplBurn();
    message.mint = object.mint ?? "";
    message.amount = object.amount ?? 0n;
    return message;
  },
};

function createBaseMplCreateMetadataV3(): MplCreateMetadataV3 {
  return { mint: "", name: "", symbol: "", uri: "" };
}

export const MplCreateMetadataV3: MessageFns<MplCreateMetadataV3> = {
  encode(message: MplCreateMetadataV3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(34).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MplCreateMetadataV3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMplCreateMetadataV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MplCreateMetadataV3 {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: MplCreateMetadataV3): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MplCreateMetadataV3>, I>>(base?: I): MplCreateMetadataV3 {
    return MplCreateMetadataV3.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MplCreateMetadataV3>, I>>(object: I): MplCreateMetadataV3 {
    const message = createBaseMplCreateMetadataV3();
    message.mint = object.mint ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseSplSetAuthority(): SplSetAuthority {
  return { mint: "", authorityType: 0, newAuthority: undefined };
}

export const SplSetAuthority: MessageFns<SplSetAuthority> = {
  encode(message: SplSetAuthority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.authorityType !== 0) {
      writer.uint32(16).uint32(message.authorityType);
    }
    if (message.newAuthority !== undefined) {
      writer.uint32(26).string(message.newAuthority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplSetAuthority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplSetAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.authorityType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newAuthority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplSetAuthority {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      authorityType: isSet(object.authorityType) ? globalThis.Number(object.authorityType) : 0,
      newAuthority: isSet(object.newAuthority) ? globalThis.String(object.newAuthority) : undefined,
    };
  },

  toJSON(message: SplSetAuthority): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.authorityType !== 0) {
      obj.authorityType = Math.round(message.authorityType);
    }
    if (message.newAuthority !== undefined) {
      obj.newAuthority = message.newAuthority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplSetAuthority>, I>>(base?: I): SplSetAuthority {
    return SplSetAuthority.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplSetAuthority>, I>>(object: I): SplSetAuthority {
    const message = createBaseSplSetAuthority();
    message.mint = object.mint ?? "";
    message.authorityType = object.authorityType ?? 0;
    message.newAuthority = object.newAuthority ?? undefined;
    return message;
  },
};

function createBasePumpfunCreate(): PumpfunCreate {
  return { name: "", symbol: "", uri: "", mint: "", bondingCurve: "", creator: "" };
}

export const PumpfunCreate: MessageFns<PumpfunCreate> = {
  encode(message: PumpfunCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    if (message.mint !== "") {
      writer.uint32(34).string(message.mint);
    }
    if (message.bondingCurve !== "") {
      writer.uint32(42).string(message.bondingCurve);
    }
    if (message.creator !== "") {
      writer.uint32(50).string(message.creator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PumpfunCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePumpfunCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bondingCurve = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PumpfunCreate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      bondingCurve: isSet(object.bondingCurve) ? globalThis.String(object.bondingCurve) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
    };
  },

  toJSON(message: PumpfunCreate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.bondingCurve !== "") {
      obj.bondingCurve = message.bondingCurve;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PumpfunCreate>, I>>(base?: I): PumpfunCreate {
    return PumpfunCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PumpfunCreate>, I>>(object: I): PumpfunCreate {
    const message = createBasePumpfunCreate();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    message.mint = object.mint ?? "";
    message.bondingCurve = object.bondingCurve ?? "";
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBasePumpfunTrade(): PumpfunTrade {
  return {
    mint: "",
    bondingCurve: "",
    solAmount: 0n,
    tokenAmount: 0n,
    direction: 0,
    user: "",
    virtualSolReserve: 0n,
    virtualTokenReserve: 0n,
  };
}

export const PumpfunTrade: MessageFns<PumpfunTrade> = {
  encode(message: PumpfunTrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.bondingCurve !== "") {
      writer.uint32(18).string(message.bondingCurve);
    }
    if (message.solAmount !== 0n) {
      if (BigInt.asUintN(64, message.solAmount) !== message.solAmount) {
        throw new globalThis.Error("value provided for field message.solAmount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.solAmount);
    }
    if (message.tokenAmount !== 0n) {
      if (BigInt.asUintN(64, message.tokenAmount) !== message.tokenAmount) {
        throw new globalThis.Error("value provided for field message.tokenAmount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.tokenAmount);
    }
    if (message.direction !== 0) {
      writer.uint32(40).uint32(message.direction);
    }
    if (message.user !== "") {
      writer.uint32(50).string(message.user);
    }
    if (message.virtualSolReserve !== 0n) {
      if (BigInt.asUintN(64, message.virtualSolReserve) !== message.virtualSolReserve) {
        throw new globalThis.Error("value provided for field message.virtualSolReserve of type uint64 too large");
      }
      writer.uint32(56).uint64(message.virtualSolReserve);
    }
    if (message.virtualTokenReserve !== 0n) {
      if (BigInt.asUintN(64, message.virtualTokenReserve) !== message.virtualTokenReserve) {
        throw new globalThis.Error("value provided for field message.virtualTokenReserve of type uint64 too large");
      }
      writer.uint32(64).uint64(message.virtualTokenReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PumpfunTrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePumpfunTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bondingCurve = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.solAmount = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tokenAmount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.direction = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.virtualSolReserve = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.virtualTokenReserve = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PumpfunTrade {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      bondingCurve: isSet(object.bondingCurve) ? globalThis.String(object.bondingCurve) : "",
      solAmount: isSet(object.solAmount) ? BigInt(object.solAmount) : 0n,
      tokenAmount: isSet(object.tokenAmount) ? BigInt(object.tokenAmount) : 0n,
      direction: isSet(object.direction) ? globalThis.Number(object.direction) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      virtualSolReserve: isSet(object.virtualSolReserve) ? BigInt(object.virtualSolReserve) : 0n,
      virtualTokenReserve: isSet(object.virtualTokenReserve) ? BigInt(object.virtualTokenReserve) : 0n,
    };
  },

  toJSON(message: PumpfunTrade): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.bondingCurve !== "") {
      obj.bondingCurve = message.bondingCurve;
    }
    if (message.solAmount !== 0n) {
      obj.solAmount = message.solAmount.toString();
    }
    if (message.tokenAmount !== 0n) {
      obj.tokenAmount = message.tokenAmount.toString();
    }
    if (message.direction !== 0) {
      obj.direction = Math.round(message.direction);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.virtualSolReserve !== 0n) {
      obj.virtualSolReserve = message.virtualSolReserve.toString();
    }
    if (message.virtualTokenReserve !== 0n) {
      obj.virtualTokenReserve = message.virtualTokenReserve.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PumpfunTrade>, I>>(base?: I): PumpfunTrade {
    return PumpfunTrade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PumpfunTrade>, I>>(object: I): PumpfunTrade {
    const message = createBasePumpfunTrade();
    message.mint = object.mint ?? "";
    message.bondingCurve = object.bondingCurve ?? "";
    message.solAmount = object.solAmount ?? 0n;
    message.tokenAmount = object.tokenAmount ?? 0n;
    message.direction = object.direction ?? 0;
    message.user = object.user ?? "";
    message.virtualSolReserve = object.virtualSolReserve ?? 0n;
    message.virtualTokenReserve = object.virtualTokenReserve ?? 0n;
    return message;
  },
};

function createBasePumpfunComplete(): PumpfunComplete {
  return { mint: "", bondingCurve: "" };
}

export const PumpfunComplete: MessageFns<PumpfunComplete> = {
  encode(message: PumpfunComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.bondingCurve !== "") {
      writer.uint32(18).string(message.bondingCurve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PumpfunComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePumpfunComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bondingCurve = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PumpfunComplete {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      bondingCurve: isSet(object.bondingCurve) ? globalThis.String(object.bondingCurve) : "",
    };
  },

  toJSON(message: PumpfunComplete): unknown {
    const obj: any = {};
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.bondingCurve !== "") {
      obj.bondingCurve = message.bondingCurve;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PumpfunComplete>, I>>(base?: I): PumpfunComplete {
    return PumpfunComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PumpfunComplete>, I>>(object: I): PumpfunComplete {
    const message = createBasePumpfunComplete();
    message.mint = object.mint ?? "";
    message.bondingCurve = object.bondingCurve ?? "";
    return message;
  },
};

function createBaseOpenbookInitializeMarket(): OpenbookInitializeMarket {
  return {
    market: "",
    baseMint: "",
    quoteMint: "",
    requestQueue: "",
    eventQueue: "",
    bids: "",
    asks: "",
    baseVault: "",
    quoteVault: "",
  };
}

export const OpenbookInitializeMarket: MessageFns<OpenbookInitializeMarket> = {
  encode(message: OpenbookInitializeMarket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.market !== "") {
      writer.uint32(10).string(message.market);
    }
    if (message.baseMint !== "") {
      writer.uint32(18).string(message.baseMint);
    }
    if (message.quoteMint !== "") {
      writer.uint32(26).string(message.quoteMint);
    }
    if (message.requestQueue !== "") {
      writer.uint32(34).string(message.requestQueue);
    }
    if (message.eventQueue !== "") {
      writer.uint32(42).string(message.eventQueue);
    }
    if (message.bids !== "") {
      writer.uint32(50).string(message.bids);
    }
    if (message.asks !== "") {
      writer.uint32(58).string(message.asks);
    }
    if (message.baseVault !== "") {
      writer.uint32(66).string(message.baseVault);
    }
    if (message.quoteVault !== "") {
      writer.uint32(74).string(message.quoteVault);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenbookInitializeMarket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenbookInitializeMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.market = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseMint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteMint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestQueue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventQueue = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bids = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.asks = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.baseVault = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.quoteVault = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenbookInitializeMarket {
    return {
      market: isSet(object.market) ? globalThis.String(object.market) : "",
      baseMint: isSet(object.baseMint) ? globalThis.String(object.baseMint) : "",
      quoteMint: isSet(object.quoteMint) ? globalThis.String(object.quoteMint) : "",
      requestQueue: isSet(object.requestQueue) ? globalThis.String(object.requestQueue) : "",
      eventQueue: isSet(object.eventQueue) ? globalThis.String(object.eventQueue) : "",
      bids: isSet(object.bids) ? globalThis.String(object.bids) : "",
      asks: isSet(object.asks) ? globalThis.String(object.asks) : "",
      baseVault: isSet(object.baseVault) ? globalThis.String(object.baseVault) : "",
      quoteVault: isSet(object.quoteVault) ? globalThis.String(object.quoteVault) : "",
    };
  },

  toJSON(message: OpenbookInitializeMarket): unknown {
    const obj: any = {};
    if (message.market !== "") {
      obj.market = message.market;
    }
    if (message.baseMint !== "") {
      obj.baseMint = message.baseMint;
    }
    if (message.quoteMint !== "") {
      obj.quoteMint = message.quoteMint;
    }
    if (message.requestQueue !== "") {
      obj.requestQueue = message.requestQueue;
    }
    if (message.eventQueue !== "") {
      obj.eventQueue = message.eventQueue;
    }
    if (message.bids !== "") {
      obj.bids = message.bids;
    }
    if (message.asks !== "") {
      obj.asks = message.asks;
    }
    if (message.baseVault !== "") {
      obj.baseVault = message.baseVault;
    }
    if (message.quoteVault !== "") {
      obj.quoteVault = message.quoteVault;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenbookInitializeMarket>, I>>(base?: I): OpenbookInitializeMarket {
    return OpenbookInitializeMarket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenbookInitializeMarket>, I>>(object: I): OpenbookInitializeMarket {
    const message = createBaseOpenbookInitializeMarket();
    message.market = object.market ?? "";
    message.baseMint = object.baseMint ?? "";
    message.quoteMint = object.quoteMint ?? "";
    message.requestQueue = object.requestQueue ?? "";
    message.eventQueue = object.eventQueue ?? "";
    message.bids = object.bids ?? "";
    message.asks = object.asks ?? "";
    message.baseVault = object.baseVault ?? "";
    message.quoteVault = object.quoteVault ?? "";
    return message;
  },
};

function createBaseRaydiumInitialize(): RaydiumInitialize {
  return {
    baseMint: "",
    quoteMint: "",
    ammId: "",
    lpMint: "",
    market: "",
    creator: "",
    openTime: 0n,
    baseReserve: 0n,
    quoteReserve: 0n,
  };
}

export const RaydiumInitialize: MessageFns<RaydiumInitialize> = {
  encode(message: RaydiumInitialize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseMint !== "") {
      writer.uint32(10).string(message.baseMint);
    }
    if (message.quoteMint !== "") {
      writer.uint32(18).string(message.quoteMint);
    }
    if (message.ammId !== "") {
      writer.uint32(26).string(message.ammId);
    }
    if (message.lpMint !== "") {
      writer.uint32(34).string(message.lpMint);
    }
    if (message.market !== "") {
      writer.uint32(42).string(message.market);
    }
    if (message.creator !== "") {
      writer.uint32(50).string(message.creator);
    }
    if (message.openTime !== 0n) {
      if (BigInt.asUintN(64, message.openTime) !== message.openTime) {
        throw new globalThis.Error("value provided for field message.openTime of type uint64 too large");
      }
      writer.uint32(56).uint64(message.openTime);
    }
    if (message.baseReserve !== 0n) {
      if (BigInt.asUintN(64, message.baseReserve) !== message.baseReserve) {
        throw new globalThis.Error("value provided for field message.baseReserve of type uint64 too large");
      }
      writer.uint32(64).uint64(message.baseReserve);
    }
    if (message.quoteReserve !== 0n) {
      if (BigInt.asUintN(64, message.quoteReserve) !== message.quoteReserve) {
        throw new globalThis.Error("value provided for field message.quoteReserve of type uint64 too large");
      }
      writer.uint32(72).uint64(message.quoteReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaydiumInitialize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaydiumInitialize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseMint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quoteMint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ammId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lpMint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.market = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.openTime = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.baseReserve = reader.uint64() as bigint;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.quoteReserve = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaydiumInitialize {
    return {
      baseMint: isSet(object.baseMint) ? globalThis.String(object.baseMint) : "",
      quoteMint: isSet(object.quoteMint) ? globalThis.String(object.quoteMint) : "",
      ammId: isSet(object.ammId) ? globalThis.String(object.ammId) : "",
      lpMint: isSet(object.lpMint) ? globalThis.String(object.lpMint) : "",
      market: isSet(object.market) ? globalThis.String(object.market) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      openTime: isSet(object.openTime) ? BigInt(object.openTime) : 0n,
      baseReserve: isSet(object.baseReserve) ? BigInt(object.baseReserve) : 0n,
      quoteReserve: isSet(object.quoteReserve) ? BigInt(object.quoteReserve) : 0n,
    };
  },

  toJSON(message: RaydiumInitialize): unknown {
    const obj: any = {};
    if (message.baseMint !== "") {
      obj.baseMint = message.baseMint;
    }
    if (message.quoteMint !== "") {
      obj.quoteMint = message.quoteMint;
    }
    if (message.ammId !== "") {
      obj.ammId = message.ammId;
    }
    if (message.lpMint !== "") {
      obj.lpMint = message.lpMint;
    }
    if (message.market !== "") {
      obj.market = message.market;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.openTime !== 0n) {
      obj.openTime = message.openTime.toString();
    }
    if (message.baseReserve !== 0n) {
      obj.baseReserve = message.baseReserve.toString();
    }
    if (message.quoteReserve !== 0n) {
      obj.quoteReserve = message.quoteReserve.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RaydiumInitialize>, I>>(base?: I): RaydiumInitialize {
    return RaydiumInitialize.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RaydiumInitialize>, I>>(object: I): RaydiumInitialize {
    const message = createBaseRaydiumInitialize();
    message.baseMint = object.baseMint ?? "";
    message.quoteMint = object.quoteMint ?? "";
    message.ammId = object.ammId ?? "";
    message.lpMint = object.lpMint ?? "";
    message.market = object.market ?? "";
    message.creator = object.creator ?? "";
    message.openTime = object.openTime ?? 0n;
    message.baseReserve = object.baseReserve ?? 0n;
    message.quoteReserve = object.quoteReserve ?? 0n;
    return message;
  },
};

function createBaseRaydiumDeposit(): RaydiumDeposit {
  return { ammId: "", lpMint: "", user: "", baseAmount: 0n, quoteAmount: 0n, baseReserve: 0n, quoteReserve: 0n };
}

export const RaydiumDeposit: MessageFns<RaydiumDeposit> = {
  encode(message: RaydiumDeposit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ammId !== "") {
      writer.uint32(10).string(message.ammId);
    }
    if (message.lpMint !== "") {
      writer.uint32(18).string(message.lpMint);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    if (message.baseAmount !== 0n) {
      if (BigInt.asUintN(64, message.baseAmount) !== message.baseAmount) {
        throw new globalThis.Error("value provided for field message.baseAmount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.baseAmount);
    }
    if (message.quoteAmount !== 0n) {
      if (BigInt.asUintN(64, message.quoteAmount) !== message.quoteAmount) {
        throw new globalThis.Error("value provided for field message.quoteAmount of type uint64 too large");
      }
      writer.uint32(40).uint64(message.quoteAmount);
    }
    if (message.baseReserve !== 0n) {
      if (BigInt.asUintN(64, message.baseReserve) !== message.baseReserve) {
        throw new globalThis.Error("value provided for field message.baseReserve of type uint64 too large");
      }
      writer.uint32(48).uint64(message.baseReserve);
    }
    if (message.quoteReserve !== 0n) {
      if (BigInt.asUintN(64, message.quoteReserve) !== message.quoteReserve) {
        throw new globalThis.Error("value provided for field message.quoteReserve of type uint64 too large");
      }
      writer.uint32(56).uint64(message.quoteReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaydiumDeposit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaydiumDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ammId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lpMint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.baseAmount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quoteAmount = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.baseReserve = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.quoteReserve = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaydiumDeposit {
    return {
      ammId: isSet(object.ammId) ? globalThis.String(object.ammId) : "",
      lpMint: isSet(object.lpMint) ? globalThis.String(object.lpMint) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      baseAmount: isSet(object.baseAmount) ? BigInt(object.baseAmount) : 0n,
      quoteAmount: isSet(object.quoteAmount) ? BigInt(object.quoteAmount) : 0n,
      baseReserve: isSet(object.baseReserve) ? BigInt(object.baseReserve) : 0n,
      quoteReserve: isSet(object.quoteReserve) ? BigInt(object.quoteReserve) : 0n,
    };
  },

  toJSON(message: RaydiumDeposit): unknown {
    const obj: any = {};
    if (message.ammId !== "") {
      obj.ammId = message.ammId;
    }
    if (message.lpMint !== "") {
      obj.lpMint = message.lpMint;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.baseAmount !== 0n) {
      obj.baseAmount = message.baseAmount.toString();
    }
    if (message.quoteAmount !== 0n) {
      obj.quoteAmount = message.quoteAmount.toString();
    }
    if (message.baseReserve !== 0n) {
      obj.baseReserve = message.baseReserve.toString();
    }
    if (message.quoteReserve !== 0n) {
      obj.quoteReserve = message.quoteReserve.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RaydiumDeposit>, I>>(base?: I): RaydiumDeposit {
    return RaydiumDeposit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RaydiumDeposit>, I>>(object: I): RaydiumDeposit {
    const message = createBaseRaydiumDeposit();
    message.ammId = object.ammId ?? "";
    message.lpMint = object.lpMint ?? "";
    message.user = object.user ?? "";
    message.baseAmount = object.baseAmount ?? 0n;
    message.quoteAmount = object.quoteAmount ?? 0n;
    message.baseReserve = object.baseReserve ?? 0n;
    message.quoteReserve = object.quoteReserve ?? 0n;
    return message;
  },
};

function createBaseRaydiumWithdraw(): RaydiumWithdraw {
  return {
    ammId: "",
    lpMint: "",
    user: "",
    lpAmount: 0n,
    baseAmount: 0n,
    quoteAmount: 0n,
    baseReserve: 0n,
    quoteReserve: 0n,
  };
}

export const RaydiumWithdraw: MessageFns<RaydiumWithdraw> = {
  encode(message: RaydiumWithdraw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ammId !== "") {
      writer.uint32(10).string(message.ammId);
    }
    if (message.lpMint !== "") {
      writer.uint32(18).string(message.lpMint);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    if (message.lpAmount !== 0n) {
      if (BigInt.asUintN(64, message.lpAmount) !== message.lpAmount) {
        throw new globalThis.Error("value provided for field message.lpAmount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.lpAmount);
    }
    if (message.baseAmount !== 0n) {
      if (BigInt.asUintN(64, message.baseAmount) !== message.baseAmount) {
        throw new globalThis.Error("value provided for field message.baseAmount of type uint64 too large");
      }
      writer.uint32(40).uint64(message.baseAmount);
    }
    if (message.quoteAmount !== 0n) {
      if (BigInt.asUintN(64, message.quoteAmount) !== message.quoteAmount) {
        throw new globalThis.Error("value provided for field message.quoteAmount of type uint64 too large");
      }
      writer.uint32(48).uint64(message.quoteAmount);
    }
    if (message.baseReserve !== 0n) {
      if (BigInt.asUintN(64, message.baseReserve) !== message.baseReserve) {
        throw new globalThis.Error("value provided for field message.baseReserve of type uint64 too large");
      }
      writer.uint32(56).uint64(message.baseReserve);
    }
    if (message.quoteReserve !== 0n) {
      if (BigInt.asUintN(64, message.quoteReserve) !== message.quoteReserve) {
        throw new globalThis.Error("value provided for field message.quoteReserve of type uint64 too large");
      }
      writer.uint32(64).uint64(message.quoteReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaydiumWithdraw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaydiumWithdraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ammId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lpMint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lpAmount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.baseAmount = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.quoteAmount = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.baseReserve = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.quoteReserve = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaydiumWithdraw {
    return {
      ammId: isSet(object.ammId) ? globalThis.String(object.ammId) : "",
      lpMint: isSet(object.lpMint) ? globalThis.String(object.lpMint) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      lpAmount: isSet(object.lpAmount) ? BigInt(object.lpAmount) : 0n,
      baseAmount: isSet(object.baseAmount) ? BigInt(object.baseAmount) : 0n,
      quoteAmount: isSet(object.quoteAmount) ? BigInt(object.quoteAmount) : 0n,
      baseReserve: isSet(object.baseReserve) ? BigInt(object.baseReserve) : 0n,
      quoteReserve: isSet(object.quoteReserve) ? BigInt(object.quoteReserve) : 0n,
    };
  },

  toJSON(message: RaydiumWithdraw): unknown {
    const obj: any = {};
    if (message.ammId !== "") {
      obj.ammId = message.ammId;
    }
    if (message.lpMint !== "") {
      obj.lpMint = message.lpMint;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.lpAmount !== 0n) {
      obj.lpAmount = message.lpAmount.toString();
    }
    if (message.baseAmount !== 0n) {
      obj.baseAmount = message.baseAmount.toString();
    }
    if (message.quoteAmount !== 0n) {
      obj.quoteAmount = message.quoteAmount.toString();
    }
    if (message.baseReserve !== 0n) {
      obj.baseReserve = message.baseReserve.toString();
    }
    if (message.quoteReserve !== 0n) {
      obj.quoteReserve = message.quoteReserve.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RaydiumWithdraw>, I>>(base?: I): RaydiumWithdraw {
    return RaydiumWithdraw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RaydiumWithdraw>, I>>(object: I): RaydiumWithdraw {
    const message = createBaseRaydiumWithdraw();
    message.ammId = object.ammId ?? "";
    message.lpMint = object.lpMint ?? "";
    message.user = object.user ?? "";
    message.lpAmount = object.lpAmount ?? 0n;
    message.baseAmount = object.baseAmount ?? 0n;
    message.quoteAmount = object.quoteAmount ?? 0n;
    message.baseReserve = object.baseReserve ?? 0n;
    message.quoteReserve = object.quoteReserve ?? 0n;
    return message;
  },
};

function createBaseRaydiumSwap(): RaydiumSwap {
  return { ammId: "", user: "", direction: 0, baseAmount: 0n, quoteAmount: 0n, baseReserve: 0n, quoteReserve: 0n };
}

export const RaydiumSwap: MessageFns<RaydiumSwap> = {
  encode(message: RaydiumSwap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ammId !== "") {
      writer.uint32(10).string(message.ammId);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    if (message.direction !== 0) {
      writer.uint32(24).uint32(message.direction);
    }
    if (message.baseAmount !== 0n) {
      if (BigInt.asUintN(64, message.baseAmount) !== message.baseAmount) {
        throw new globalThis.Error("value provided for field message.baseAmount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.baseAmount);
    }
    if (message.quoteAmount !== 0n) {
      if (BigInt.asUintN(64, message.quoteAmount) !== message.quoteAmount) {
        throw new globalThis.Error("value provided for field message.quoteAmount of type uint64 too large");
      }
      writer.uint32(40).uint64(message.quoteAmount);
    }
    if (message.baseReserve !== 0n) {
      if (BigInt.asUintN(64, message.baseReserve) !== message.baseReserve) {
        throw new globalThis.Error("value provided for field message.baseReserve of type uint64 too large");
      }
      writer.uint32(48).uint64(message.baseReserve);
    }
    if (message.quoteReserve !== 0n) {
      if (BigInt.asUintN(64, message.quoteReserve) !== message.quoteReserve) {
        throw new globalThis.Error("value provided for field message.quoteReserve of type uint64 too large");
      }
      writer.uint32(56).uint64(message.quoteReserve);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaydiumSwap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaydiumSwap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ammId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.direction = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.baseAmount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quoteAmount = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.baseReserve = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.quoteReserve = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaydiumSwap {
    return {
      ammId: isSet(object.ammId) ? globalThis.String(object.ammId) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      direction: isSet(object.direction) ? globalThis.Number(object.direction) : 0,
      baseAmount: isSet(object.baseAmount) ? BigInt(object.baseAmount) : 0n,
      quoteAmount: isSet(object.quoteAmount) ? BigInt(object.quoteAmount) : 0n,
      baseReserve: isSet(object.baseReserve) ? BigInt(object.baseReserve) : 0n,
      quoteReserve: isSet(object.quoteReserve) ? BigInt(object.quoteReserve) : 0n,
    };
  },

  toJSON(message: RaydiumSwap): unknown {
    const obj: any = {};
    if (message.ammId !== "") {
      obj.ammId = message.ammId;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.direction !== 0) {
      obj.direction = Math.round(message.direction);
    }
    if (message.baseAmount !== 0n) {
      obj.baseAmount = message.baseAmount.toString();
    }
    if (message.quoteAmount !== 0n) {
      obj.quoteAmount = message.quoteAmount.toString();
    }
    if (message.baseReserve !== 0n) {
      obj.baseReserve = message.baseReserve.toString();
    }
    if (message.quoteReserve !== 0n) {
      obj.quoteReserve = message.quoteReserve.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RaydiumSwap>, I>>(base?: I): RaydiumSwap {
    return RaydiumSwap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RaydiumSwap>, I>>(object: I): RaydiumSwap {
    const message = createBaseRaydiumSwap();
    message.ammId = object.ammId ?? "";
    message.user = object.user ?? "";
    message.direction = object.direction ?? 0;
    message.baseAmount = object.baseAmount ?? 0n;
    message.quoteAmount = object.quoteAmount ?? 0n;
    message.baseReserve = object.baseReserve ?? 0n;
    message.quoteReserve = object.quoteReserve ?? 0n;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
