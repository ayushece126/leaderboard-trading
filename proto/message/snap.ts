// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: message/snap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "snap";

export interface MintSnap {
  decimals: string;
  createdAt: string;
  mintAuthority?: string | undefined;
  freezeAuthority?: string | undefined;
  authorityUpdatedAt?: string | undefined;
  name?: string | undefined;
  symbol?: string | undefined;
  metadataUri?: string | undefined;
  metadataUpdatedAt?: string | undefined;
  minted?: string | undefined;
  burnt?: string | undefined;
  supply?: string | undefined;
  bondingCurve?: string | undefined;
  description?: string | undefined;
  imageUri?: string | undefined;
  socials?: string | undefined;
  address?: string | undefined;
}

export interface HolderStatSnap {
  devBuy?: string | undefined;
  devHolding?: string | undefined;
  devHoldingPct?: string | undefined;
  bundleBuy?: string | undefined;
  bundleCount?: string | undefined;
  bundleHolding?: string | undefined;
  bundleHoldingPct?: string | undefined;
  sniperBuy?: string | undefined;
  sniperCount?: string | undefined;
  sniperHolding?: string | undefined;
  sniperHoldingPct?: string | undefined;
  insiderCount?: string | undefined;
  insiderHolding?: string | undefined;
  insiderHoldingPct?: string | undefined;
  t10Holding?: string | undefined;
  t10HoldingPct?: string | undefined;
  termCount?: string | undefined;
  termHolding?: string | undefined;
  termHoldingPct?: string | undefined;
  susCount?: string | undefined;
  susHolding?: string | undefined;
  susHoldingPct?: string | undefined;
  dBundleCount?: string | undefined;
  dBundleHolding?: string | undefined;
  dBundleHoldingPct?: string | undefined;
  holders?: string | undefined;
  address?: string | undefined;
}

export interface PumpfunSnap {
  mintAddress: string;
  baseReserve: string;
  quoteReserve: string;
  devWalletAddress: string;
  createdAtSlot: string;
  createdAt: string;
  updatedAt: string;
  isCompleted?: string | undefined;
  raydiumAmmId?: string | undefined;
  bondingCurvePct?: string | undefined;
  buys?: string | undefined;
  sells?: string | undefined;
  buyVolume?: string | undefined;
  sellVolume?: string | undefined;
  volumeUSD?: string | undefined;
  liquidityUSD?: string | undefined;
  mcapUSD?: string | undefined;
  address?: string | undefined;
}

export interface RaydiumSnap {
  baseMint: string;
  quoteMint: string;
  lpMint: string;
  market: string;
  isSolQuote: string;
  baseReserve: string;
  quoteReserve: string;
  initialBaseReserve: string;
  initialQuoteReserve: string;
  devWalletAddress: string;
  createdAt: string;
  updatedAt: string;
  createdAtSlot: string;
  buys?: string | undefined;
  sells?: string | undefined;
  buyVolume?: string | undefined;
  sellVolume?: string | undefined;
  volumeUSD?: string | undefined;
  liquidityUSD?: string | undefined;
  mcapUSD?: string | undefined;
  address?: string | undefined;
}

export interface PoolStatSnap {
  baseReserve: string;
  quoteReserve: string;
  buys?: string | undefined;
  sells?: string | undefined;
  buyVolume?: string | undefined;
  sellVolume?: string | undefined;
  address?: string | undefined;
  timestamp?: string | undefined;
}

export interface PumpfunDevStatSnap {
  created: string;
  migrated: string;
  address?: string | undefined;
}

function createBaseMintSnap(): MintSnap {
  return {
    decimals: "",
    createdAt: "",
    mintAuthority: undefined,
    freezeAuthority: undefined,
    authorityUpdatedAt: undefined,
    name: undefined,
    symbol: undefined,
    metadataUri: undefined,
    metadataUpdatedAt: undefined,
    minted: undefined,
    burnt: undefined,
    supply: undefined,
    bondingCurve: undefined,
    description: undefined,
    imageUri: undefined,
    socials: undefined,
    address: undefined,
  };
}

export const MintSnap: MessageFns<MintSnap> = {
  encode(message: MintSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decimals !== "") {
      writer.uint32(10).string(message.decimals);
    }
    if (message.createdAt !== "") {
      writer.uint32(18).string(message.createdAt);
    }
    if (message.mintAuthority !== undefined) {
      writer.uint32(26).string(message.mintAuthority);
    }
    if (message.freezeAuthority !== undefined) {
      writer.uint32(34).string(message.freezeAuthority);
    }
    if (message.authorityUpdatedAt !== undefined) {
      writer.uint32(42).string(message.authorityUpdatedAt);
    }
    if (message.name !== undefined) {
      writer.uint32(50).string(message.name);
    }
    if (message.symbol !== undefined) {
      writer.uint32(58).string(message.symbol);
    }
    if (message.metadataUri !== undefined) {
      writer.uint32(66).string(message.metadataUri);
    }
    if (message.metadataUpdatedAt !== undefined) {
      writer.uint32(74).string(message.metadataUpdatedAt);
    }
    if (message.minted !== undefined) {
      writer.uint32(82).string(message.minted);
    }
    if (message.burnt !== undefined) {
      writer.uint32(90).string(message.burnt);
    }
    if (message.supply !== undefined) {
      writer.uint32(98).string(message.supply);
    }
    if (message.bondingCurve !== undefined) {
      writer.uint32(106).string(message.bondingCurve);
    }
    if (message.description !== undefined) {
      writer.uint32(114).string(message.description);
    }
    if (message.imageUri !== undefined) {
      writer.uint32(122).string(message.imageUri);
    }
    if (message.socials !== undefined) {
      writer.uint32(130).string(message.socials);
    }
    if (message.address !== undefined) {
      writer.uint32(138).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.decimals = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mintAuthority = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.freezeAuthority = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authorityUpdatedAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadataUri = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadataUpdatedAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.minted = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.burnt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.supply = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bondingCurve = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.socials = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintSnap {
    return {
      decimals: isSet(object.decimals) ? globalThis.String(object.decimals) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      mintAuthority: isSet(object.mintAuthority) ? globalThis.String(object.mintAuthority) : undefined,
      freezeAuthority: isSet(object.freezeAuthority) ? globalThis.String(object.freezeAuthority) : undefined,
      authorityUpdatedAt: isSet(object.authorityUpdatedAt) ? globalThis.String(object.authorityUpdatedAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : undefined,
      metadataUri: isSet(object.metadataUri) ? globalThis.String(object.metadataUri) : undefined,
      metadataUpdatedAt: isSet(object.metadataUpdatedAt) ? globalThis.String(object.metadataUpdatedAt) : undefined,
      minted: isSet(object.minted) ? globalThis.String(object.minted) : undefined,
      burnt: isSet(object.burnt) ? globalThis.String(object.burnt) : undefined,
      supply: isSet(object.supply) ? globalThis.String(object.supply) : undefined,
      bondingCurve: isSet(object.bondingCurve) ? globalThis.String(object.bondingCurve) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : undefined,
      socials: isSet(object.socials) ? globalThis.String(object.socials) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
    };
  },

  toJSON(message: MintSnap): unknown {
    const obj: any = {};
    if (message.decimals !== "") {
      obj.decimals = message.decimals;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.mintAuthority !== undefined) {
      obj.mintAuthority = message.mintAuthority;
    }
    if (message.freezeAuthority !== undefined) {
      obj.freezeAuthority = message.freezeAuthority;
    }
    if (message.authorityUpdatedAt !== undefined) {
      obj.authorityUpdatedAt = message.authorityUpdatedAt;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.metadataUri !== undefined) {
      obj.metadataUri = message.metadataUri;
    }
    if (message.metadataUpdatedAt !== undefined) {
      obj.metadataUpdatedAt = message.metadataUpdatedAt;
    }
    if (message.minted !== undefined) {
      obj.minted = message.minted;
    }
    if (message.burnt !== undefined) {
      obj.burnt = message.burnt;
    }
    if (message.supply !== undefined) {
      obj.supply = message.supply;
    }
    if (message.bondingCurve !== undefined) {
      obj.bondingCurve = message.bondingCurve;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.socials !== undefined) {
      obj.socials = message.socials;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintSnap>, I>>(base?: I): MintSnap {
    return MintSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintSnap>, I>>(object: I): MintSnap {
    const message = createBaseMintSnap();
    message.decimals = object.decimals ?? "";
    message.createdAt = object.createdAt ?? "";
    message.mintAuthority = object.mintAuthority ?? undefined;
    message.freezeAuthority = object.freezeAuthority ?? undefined;
    message.authorityUpdatedAt = object.authorityUpdatedAt ?? undefined;
    message.name = object.name ?? undefined;
    message.symbol = object.symbol ?? undefined;
    message.metadataUri = object.metadataUri ?? undefined;
    message.metadataUpdatedAt = object.metadataUpdatedAt ?? undefined;
    message.minted = object.minted ?? undefined;
    message.burnt = object.burnt ?? undefined;
    message.supply = object.supply ?? undefined;
    message.bondingCurve = object.bondingCurve ?? undefined;
    message.description = object.description ?? undefined;
    message.imageUri = object.imageUri ?? undefined;
    message.socials = object.socials ?? undefined;
    message.address = object.address ?? undefined;
    return message;
  },
};

function createBaseHolderStatSnap(): HolderStatSnap {
  return {
    devBuy: undefined,
    devHolding: undefined,
    devHoldingPct: undefined,
    bundleBuy: undefined,
    bundleCount: undefined,
    bundleHolding: undefined,
    bundleHoldingPct: undefined,
    sniperBuy: undefined,
    sniperCount: undefined,
    sniperHolding: undefined,
    sniperHoldingPct: undefined,
    insiderCount: undefined,
    insiderHolding: undefined,
    insiderHoldingPct: undefined,
    t10Holding: undefined,
    t10HoldingPct: undefined,
    termCount: undefined,
    termHolding: undefined,
    termHoldingPct: undefined,
    susCount: undefined,
    susHolding: undefined,
    susHoldingPct: undefined,
    dBundleCount: undefined,
    dBundleHolding: undefined,
    dBundleHoldingPct: undefined,
    holders: undefined,
    address: undefined,
  };
}

export const HolderStatSnap: MessageFns<HolderStatSnap> = {
  encode(message: HolderStatSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.devBuy !== undefined) {
      writer.uint32(10).string(message.devBuy);
    }
    if (message.devHolding !== undefined) {
      writer.uint32(18).string(message.devHolding);
    }
    if (message.devHoldingPct !== undefined) {
      writer.uint32(26).string(message.devHoldingPct);
    }
    if (message.bundleBuy !== undefined) {
      writer.uint32(34).string(message.bundleBuy);
    }
    if (message.bundleCount !== undefined) {
      writer.uint32(42).string(message.bundleCount);
    }
    if (message.bundleHolding !== undefined) {
      writer.uint32(50).string(message.bundleHolding);
    }
    if (message.bundleHoldingPct !== undefined) {
      writer.uint32(58).string(message.bundleHoldingPct);
    }
    if (message.sniperBuy !== undefined) {
      writer.uint32(66).string(message.sniperBuy);
    }
    if (message.sniperCount !== undefined) {
      writer.uint32(74).string(message.sniperCount);
    }
    if (message.sniperHolding !== undefined) {
      writer.uint32(82).string(message.sniperHolding);
    }
    if (message.sniperHoldingPct !== undefined) {
      writer.uint32(90).string(message.sniperHoldingPct);
    }
    if (message.insiderCount !== undefined) {
      writer.uint32(98).string(message.insiderCount);
    }
    if (message.insiderHolding !== undefined) {
      writer.uint32(106).string(message.insiderHolding);
    }
    if (message.insiderHoldingPct !== undefined) {
      writer.uint32(114).string(message.insiderHoldingPct);
    }
    if (message.t10Holding !== undefined) {
      writer.uint32(122).string(message.t10Holding);
    }
    if (message.t10HoldingPct !== undefined) {
      writer.uint32(130).string(message.t10HoldingPct);
    }
    if (message.termCount !== undefined) {
      writer.uint32(138).string(message.termCount);
    }
    if (message.termHolding !== undefined) {
      writer.uint32(146).string(message.termHolding);
    }
    if (message.termHoldingPct !== undefined) {
      writer.uint32(154).string(message.termHoldingPct);
    }
    if (message.susCount !== undefined) {
      writer.uint32(162).string(message.susCount);
    }
    if (message.susHolding !== undefined) {
      writer.uint32(170).string(message.susHolding);
    }
    if (message.susHoldingPct !== undefined) {
      writer.uint32(178).string(message.susHoldingPct);
    }
    if (message.dBundleCount !== undefined) {
      writer.uint32(186).string(message.dBundleCount);
    }
    if (message.dBundleHolding !== undefined) {
      writer.uint32(194).string(message.dBundleHolding);
    }
    if (message.dBundleHoldingPct !== undefined) {
      writer.uint32(202).string(message.dBundleHoldingPct);
    }
    if (message.holders !== undefined) {
      writer.uint32(210).string(message.holders);
    }
    if (message.address !== undefined) {
      writer.uint32(218).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HolderStatSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHolderStatSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.devBuy = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.devHolding = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.devHoldingPct = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bundleBuy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bundleCount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bundleHolding = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bundleHoldingPct = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sniperBuy = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sniperCount = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sniperHolding = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sniperHoldingPct = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.insiderCount = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.insiderHolding = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.insiderHoldingPct = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.t10Holding = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.t10HoldingPct = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.termCount = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.termHolding = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.termHoldingPct = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.susCount = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.susHolding = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.susHoldingPct = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.dBundleCount = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.dBundleHolding = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.dBundleHoldingPct = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.holders = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HolderStatSnap {
    return {
      devBuy: isSet(object.devBuy) ? globalThis.String(object.devBuy) : undefined,
      devHolding: isSet(object.devHolding) ? globalThis.String(object.devHolding) : undefined,
      devHoldingPct: isSet(object.devHoldingPct) ? globalThis.String(object.devHoldingPct) : undefined,
      bundleBuy: isSet(object.bundleBuy) ? globalThis.String(object.bundleBuy) : undefined,
      bundleCount: isSet(object.bundleCount) ? globalThis.String(object.bundleCount) : undefined,
      bundleHolding: isSet(object.bundleHolding) ? globalThis.String(object.bundleHolding) : undefined,
      bundleHoldingPct: isSet(object.bundleHoldingPct) ? globalThis.String(object.bundleHoldingPct) : undefined,
      sniperBuy: isSet(object.sniperBuy) ? globalThis.String(object.sniperBuy) : undefined,
      sniperCount: isSet(object.sniperCount) ? globalThis.String(object.sniperCount) : undefined,
      sniperHolding: isSet(object.sniperHolding) ? globalThis.String(object.sniperHolding) : undefined,
      sniperHoldingPct: isSet(object.sniperHoldingPct) ? globalThis.String(object.sniperHoldingPct) : undefined,
      insiderCount: isSet(object.insiderCount) ? globalThis.String(object.insiderCount) : undefined,
      insiderHolding: isSet(object.insiderHolding) ? globalThis.String(object.insiderHolding) : undefined,
      insiderHoldingPct: isSet(object.insiderHoldingPct) ? globalThis.String(object.insiderHoldingPct) : undefined,
      t10Holding: isSet(object.t10Holding) ? globalThis.String(object.t10Holding) : undefined,
      t10HoldingPct: isSet(object.t10HoldingPct) ? globalThis.String(object.t10HoldingPct) : undefined,
      termCount: isSet(object.termCount) ? globalThis.String(object.termCount) : undefined,
      termHolding: isSet(object.termHolding) ? globalThis.String(object.termHolding) : undefined,
      termHoldingPct: isSet(object.termHoldingPct) ? globalThis.String(object.termHoldingPct) : undefined,
      susCount: isSet(object.susCount) ? globalThis.String(object.susCount) : undefined,
      susHolding: isSet(object.susHolding) ? globalThis.String(object.susHolding) : undefined,
      susHoldingPct: isSet(object.susHoldingPct) ? globalThis.String(object.susHoldingPct) : undefined,
      dBundleCount: isSet(object.dBundleCount) ? globalThis.String(object.dBundleCount) : undefined,
      dBundleHolding: isSet(object.dBundleHolding) ? globalThis.String(object.dBundleHolding) : undefined,
      dBundleHoldingPct: isSet(object.dBundleHoldingPct) ? globalThis.String(object.dBundleHoldingPct) : undefined,
      holders: isSet(object.holders) ? globalThis.String(object.holders) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
    };
  },

  toJSON(message: HolderStatSnap): unknown {
    const obj: any = {};
    if (message.devBuy !== undefined) {
      obj.devBuy = message.devBuy;
    }
    if (message.devHolding !== undefined) {
      obj.devHolding = message.devHolding;
    }
    if (message.devHoldingPct !== undefined) {
      obj.devHoldingPct = message.devHoldingPct;
    }
    if (message.bundleBuy !== undefined) {
      obj.bundleBuy = message.bundleBuy;
    }
    if (message.bundleCount !== undefined) {
      obj.bundleCount = message.bundleCount;
    }
    if (message.bundleHolding !== undefined) {
      obj.bundleHolding = message.bundleHolding;
    }
    if (message.bundleHoldingPct !== undefined) {
      obj.bundleHoldingPct = message.bundleHoldingPct;
    }
    if (message.sniperBuy !== undefined) {
      obj.sniperBuy = message.sniperBuy;
    }
    if (message.sniperCount !== undefined) {
      obj.sniperCount = message.sniperCount;
    }
    if (message.sniperHolding !== undefined) {
      obj.sniperHolding = message.sniperHolding;
    }
    if (message.sniperHoldingPct !== undefined) {
      obj.sniperHoldingPct = message.sniperHoldingPct;
    }
    if (message.insiderCount !== undefined) {
      obj.insiderCount = message.insiderCount;
    }
    if (message.insiderHolding !== undefined) {
      obj.insiderHolding = message.insiderHolding;
    }
    if (message.insiderHoldingPct !== undefined) {
      obj.insiderHoldingPct = message.insiderHoldingPct;
    }
    if (message.t10Holding !== undefined) {
      obj.t10Holding = message.t10Holding;
    }
    if (message.t10HoldingPct !== undefined) {
      obj.t10HoldingPct = message.t10HoldingPct;
    }
    if (message.termCount !== undefined) {
      obj.termCount = message.termCount;
    }
    if (message.termHolding !== undefined) {
      obj.termHolding = message.termHolding;
    }
    if (message.termHoldingPct !== undefined) {
      obj.termHoldingPct = message.termHoldingPct;
    }
    if (message.susCount !== undefined) {
      obj.susCount = message.susCount;
    }
    if (message.susHolding !== undefined) {
      obj.susHolding = message.susHolding;
    }
    if (message.susHoldingPct !== undefined) {
      obj.susHoldingPct = message.susHoldingPct;
    }
    if (message.dBundleCount !== undefined) {
      obj.dBundleCount = message.dBundleCount;
    }
    if (message.dBundleHolding !== undefined) {
      obj.dBundleHolding = message.dBundleHolding;
    }
    if (message.dBundleHoldingPct !== undefined) {
      obj.dBundleHoldingPct = message.dBundleHoldingPct;
    }
    if (message.holders !== undefined) {
      obj.holders = message.holders;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HolderStatSnap>, I>>(base?: I): HolderStatSnap {
    return HolderStatSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HolderStatSnap>, I>>(object: I): HolderStatSnap {
    const message = createBaseHolderStatSnap();
    message.devBuy = object.devBuy ?? undefined;
    message.devHolding = object.devHolding ?? undefined;
    message.devHoldingPct = object.devHoldingPct ?? undefined;
    message.bundleBuy = object.bundleBuy ?? undefined;
    message.bundleCount = object.bundleCount ?? undefined;
    message.bundleHolding = object.bundleHolding ?? undefined;
    message.bundleHoldingPct = object.bundleHoldingPct ?? undefined;
    message.sniperBuy = object.sniperBuy ?? undefined;
    message.sniperCount = object.sniperCount ?? undefined;
    message.sniperHolding = object.sniperHolding ?? undefined;
    message.sniperHoldingPct = object.sniperHoldingPct ?? undefined;
    message.insiderCount = object.insiderCount ?? undefined;
    message.insiderHolding = object.insiderHolding ?? undefined;
    message.insiderHoldingPct = object.insiderHoldingPct ?? undefined;
    message.t10Holding = object.t10Holding ?? undefined;
    message.t10HoldingPct = object.t10HoldingPct ?? undefined;
    message.termCount = object.termCount ?? undefined;
    message.termHolding = object.termHolding ?? undefined;
    message.termHoldingPct = object.termHoldingPct ?? undefined;
    message.susCount = object.susCount ?? undefined;
    message.susHolding = object.susHolding ?? undefined;
    message.susHoldingPct = object.susHoldingPct ?? undefined;
    message.dBundleCount = object.dBundleCount ?? undefined;
    message.dBundleHolding = object.dBundleHolding ?? undefined;
    message.dBundleHoldingPct = object.dBundleHoldingPct ?? undefined;
    message.holders = object.holders ?? undefined;
    message.address = object.address ?? undefined;
    return message;
  },
};

function createBasePumpfunSnap(): PumpfunSnap {
  return {
    mintAddress: "",
    baseReserve: "",
    quoteReserve: "",
    devWalletAddress: "",
    createdAtSlot: "",
    createdAt: "",
    updatedAt: "",
    isCompleted: undefined,
    raydiumAmmId: undefined,
    bondingCurvePct: undefined,
    buys: undefined,
    sells: undefined,
    buyVolume: undefined,
    sellVolume: undefined,
    volumeUSD: undefined,
    liquidityUSD: undefined,
    mcapUSD: undefined,
    address: undefined,
  };
}

export const PumpfunSnap: MessageFns<PumpfunSnap> = {
  encode(message: PumpfunSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mintAddress !== "") {
      writer.uint32(10).string(message.mintAddress);
    }
    if (message.baseReserve !== "") {
      writer.uint32(18).string(message.baseReserve);
    }
    if (message.quoteReserve !== "") {
      writer.uint32(26).string(message.quoteReserve);
    }
    if (message.devWalletAddress !== "") {
      writer.uint32(34).string(message.devWalletAddress);
    }
    if (message.createdAtSlot !== "") {
      writer.uint32(42).string(message.createdAtSlot);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    if (message.isCompleted !== undefined) {
      writer.uint32(66).string(message.isCompleted);
    }
    if (message.raydiumAmmId !== undefined) {
      writer.uint32(74).string(message.raydiumAmmId);
    }
    if (message.bondingCurvePct !== undefined) {
      writer.uint32(82).string(message.bondingCurvePct);
    }
    if (message.buys !== undefined) {
      writer.uint32(90).string(message.buys);
    }
    if (message.sells !== undefined) {
      writer.uint32(98).string(message.sells);
    }
    if (message.buyVolume !== undefined) {
      writer.uint32(106).string(message.buyVolume);
    }
    if (message.sellVolume !== undefined) {
      writer.uint32(114).string(message.sellVolume);
    }
    if (message.volumeUSD !== undefined) {
      writer.uint32(122).string(message.volumeUSD);
    }
    if (message.liquidityUSD !== undefined) {
      writer.uint32(130).string(message.liquidityUSD);
    }
    if (message.mcapUSD !== undefined) {
      writer.uint32(138).string(message.mcapUSD);
    }
    if (message.address !== undefined) {
      writer.uint32(146).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PumpfunSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePumpfunSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mintAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseReserve = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteReserve = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.devWalletAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAtSlot = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.isCompleted = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.raydiumAmmId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bondingCurvePct = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.buys = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.sells = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.buyVolume = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.sellVolume = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.volumeUSD = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.liquidityUSD = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.mcapUSD = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PumpfunSnap {
    return {
      mintAddress: isSet(object.mintAddress) ? globalThis.String(object.mintAddress) : "",
      baseReserve: isSet(object.baseReserve) ? globalThis.String(object.baseReserve) : "",
      quoteReserve: isSet(object.quoteReserve) ? globalThis.String(object.quoteReserve) : "",
      devWalletAddress: isSet(object.devWalletAddress) ? globalThis.String(object.devWalletAddress) : "",
      createdAtSlot: isSet(object.createdAtSlot) ? globalThis.String(object.createdAtSlot) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      isCompleted: isSet(object.isCompleted) ? globalThis.String(object.isCompleted) : undefined,
      raydiumAmmId: isSet(object.raydiumAmmId) ? globalThis.String(object.raydiumAmmId) : undefined,
      bondingCurvePct: isSet(object.bondingCurvePct) ? globalThis.String(object.bondingCurvePct) : undefined,
      buys: isSet(object.buys) ? globalThis.String(object.buys) : undefined,
      sells: isSet(object.sells) ? globalThis.String(object.sells) : undefined,
      buyVolume: isSet(object.buyVolume) ? globalThis.String(object.buyVolume) : undefined,
      sellVolume: isSet(object.sellVolume) ? globalThis.String(object.sellVolume) : undefined,
      volumeUSD: isSet(object.volumeUSD) ? globalThis.String(object.volumeUSD) : undefined,
      liquidityUSD: isSet(object.liquidityUSD) ? globalThis.String(object.liquidityUSD) : undefined,
      mcapUSD: isSet(object.mcapUSD) ? globalThis.String(object.mcapUSD) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
    };
  },

  toJSON(message: PumpfunSnap): unknown {
    const obj: any = {};
    if (message.mintAddress !== "") {
      obj.mintAddress = message.mintAddress;
    }
    if (message.baseReserve !== "") {
      obj.baseReserve = message.baseReserve;
    }
    if (message.quoteReserve !== "") {
      obj.quoteReserve = message.quoteReserve;
    }
    if (message.devWalletAddress !== "") {
      obj.devWalletAddress = message.devWalletAddress;
    }
    if (message.createdAtSlot !== "") {
      obj.createdAtSlot = message.createdAtSlot;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.isCompleted !== undefined) {
      obj.isCompleted = message.isCompleted;
    }
    if (message.raydiumAmmId !== undefined) {
      obj.raydiumAmmId = message.raydiumAmmId;
    }
    if (message.bondingCurvePct !== undefined) {
      obj.bondingCurvePct = message.bondingCurvePct;
    }
    if (message.buys !== undefined) {
      obj.buys = message.buys;
    }
    if (message.sells !== undefined) {
      obj.sells = message.sells;
    }
    if (message.buyVolume !== undefined) {
      obj.buyVolume = message.buyVolume;
    }
    if (message.sellVolume !== undefined) {
      obj.sellVolume = message.sellVolume;
    }
    if (message.volumeUSD !== undefined) {
      obj.volumeUSD = message.volumeUSD;
    }
    if (message.liquidityUSD !== undefined) {
      obj.liquidityUSD = message.liquidityUSD;
    }
    if (message.mcapUSD !== undefined) {
      obj.mcapUSD = message.mcapUSD;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PumpfunSnap>, I>>(base?: I): PumpfunSnap {
    return PumpfunSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PumpfunSnap>, I>>(object: I): PumpfunSnap {
    const message = createBasePumpfunSnap();
    message.mintAddress = object.mintAddress ?? "";
    message.baseReserve = object.baseReserve ?? "";
    message.quoteReserve = object.quoteReserve ?? "";
    message.devWalletAddress = object.devWalletAddress ?? "";
    message.createdAtSlot = object.createdAtSlot ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.isCompleted = object.isCompleted ?? undefined;
    message.raydiumAmmId = object.raydiumAmmId ?? undefined;
    message.bondingCurvePct = object.bondingCurvePct ?? undefined;
    message.buys = object.buys ?? undefined;
    message.sells = object.sells ?? undefined;
    message.buyVolume = object.buyVolume ?? undefined;
    message.sellVolume = object.sellVolume ?? undefined;
    message.volumeUSD = object.volumeUSD ?? undefined;
    message.liquidityUSD = object.liquidityUSD ?? undefined;
    message.mcapUSD = object.mcapUSD ?? undefined;
    message.address = object.address ?? undefined;
    return message;
  },
};

function createBaseRaydiumSnap(): RaydiumSnap {
  return {
    baseMint: "",
    quoteMint: "",
    lpMint: "",
    market: "",
    isSolQuote: "",
    baseReserve: "",
    quoteReserve: "",
    initialBaseReserve: "",
    initialQuoteReserve: "",
    devWalletAddress: "",
    createdAt: "",
    updatedAt: "",
    createdAtSlot: "",
    buys: undefined,
    sells: undefined,
    buyVolume: undefined,
    sellVolume: undefined,
    volumeUSD: undefined,
    liquidityUSD: undefined,
    mcapUSD: undefined,
    address: undefined,
  };
}

export const RaydiumSnap: MessageFns<RaydiumSnap> = {
  encode(message: RaydiumSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseMint !== "") {
      writer.uint32(10).string(message.baseMint);
    }
    if (message.quoteMint !== "") {
      writer.uint32(18).string(message.quoteMint);
    }
    if (message.lpMint !== "") {
      writer.uint32(26).string(message.lpMint);
    }
    if (message.market !== "") {
      writer.uint32(34).string(message.market);
    }
    if (message.isSolQuote !== "") {
      writer.uint32(42).string(message.isSolQuote);
    }
    if (message.baseReserve !== "") {
      writer.uint32(50).string(message.baseReserve);
    }
    if (message.quoteReserve !== "") {
      writer.uint32(58).string(message.quoteReserve);
    }
    if (message.initialBaseReserve !== "") {
      writer.uint32(66).string(message.initialBaseReserve);
    }
    if (message.initialQuoteReserve !== "") {
      writer.uint32(74).string(message.initialQuoteReserve);
    }
    if (message.devWalletAddress !== "") {
      writer.uint32(82).string(message.devWalletAddress);
    }
    if (message.createdAt !== "") {
      writer.uint32(90).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(98).string(message.updatedAt);
    }
    if (message.createdAtSlot !== "") {
      writer.uint32(106).string(message.createdAtSlot);
    }
    if (message.buys !== undefined) {
      writer.uint32(114).string(message.buys);
    }
    if (message.sells !== undefined) {
      writer.uint32(122).string(message.sells);
    }
    if (message.buyVolume !== undefined) {
      writer.uint32(130).string(message.buyVolume);
    }
    if (message.sellVolume !== undefined) {
      writer.uint32(138).string(message.sellVolume);
    }
    if (message.volumeUSD !== undefined) {
      writer.uint32(146).string(message.volumeUSD);
    }
    if (message.liquidityUSD !== undefined) {
      writer.uint32(154).string(message.liquidityUSD);
    }
    if (message.mcapUSD !== undefined) {
      writer.uint32(162).string(message.mcapUSD);
    }
    if (message.address !== undefined) {
      writer.uint32(170).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaydiumSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaydiumSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseMint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quoteMint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lpMint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.market = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.isSolQuote = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.baseReserve = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.quoteReserve = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.initialBaseReserve = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.initialQuoteReserve = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.devWalletAddress = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAtSlot = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.buys = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.sells = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.buyVolume = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.sellVolume = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.volumeUSD = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.liquidityUSD = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.mcapUSD = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaydiumSnap {
    return {
      baseMint: isSet(object.baseMint) ? globalThis.String(object.baseMint) : "",
      quoteMint: isSet(object.quoteMint) ? globalThis.String(object.quoteMint) : "",
      lpMint: isSet(object.lpMint) ? globalThis.String(object.lpMint) : "",
      market: isSet(object.market) ? globalThis.String(object.market) : "",
      isSolQuote: isSet(object.isSolQuote) ? globalThis.String(object.isSolQuote) : "",
      baseReserve: isSet(object.baseReserve) ? globalThis.String(object.baseReserve) : "",
      quoteReserve: isSet(object.quoteReserve) ? globalThis.String(object.quoteReserve) : "",
      initialBaseReserve: isSet(object.initialBaseReserve) ? globalThis.String(object.initialBaseReserve) : "",
      initialQuoteReserve: isSet(object.initialQuoteReserve) ? globalThis.String(object.initialQuoteReserve) : "",
      devWalletAddress: isSet(object.devWalletAddress) ? globalThis.String(object.devWalletAddress) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      createdAtSlot: isSet(object.createdAtSlot) ? globalThis.String(object.createdAtSlot) : "",
      buys: isSet(object.buys) ? globalThis.String(object.buys) : undefined,
      sells: isSet(object.sells) ? globalThis.String(object.sells) : undefined,
      buyVolume: isSet(object.buyVolume) ? globalThis.String(object.buyVolume) : undefined,
      sellVolume: isSet(object.sellVolume) ? globalThis.String(object.sellVolume) : undefined,
      volumeUSD: isSet(object.volumeUSD) ? globalThis.String(object.volumeUSD) : undefined,
      liquidityUSD: isSet(object.liquidityUSD) ? globalThis.String(object.liquidityUSD) : undefined,
      mcapUSD: isSet(object.mcapUSD) ? globalThis.String(object.mcapUSD) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
    };
  },

  toJSON(message: RaydiumSnap): unknown {
    const obj: any = {};
    if (message.baseMint !== "") {
      obj.baseMint = message.baseMint;
    }
    if (message.quoteMint !== "") {
      obj.quoteMint = message.quoteMint;
    }
    if (message.lpMint !== "") {
      obj.lpMint = message.lpMint;
    }
    if (message.market !== "") {
      obj.market = message.market;
    }
    if (message.isSolQuote !== "") {
      obj.isSolQuote = message.isSolQuote;
    }
    if (message.baseReserve !== "") {
      obj.baseReserve = message.baseReserve;
    }
    if (message.quoteReserve !== "") {
      obj.quoteReserve = message.quoteReserve;
    }
    if (message.initialBaseReserve !== "") {
      obj.initialBaseReserve = message.initialBaseReserve;
    }
    if (message.initialQuoteReserve !== "") {
      obj.initialQuoteReserve = message.initialQuoteReserve;
    }
    if (message.devWalletAddress !== "") {
      obj.devWalletAddress = message.devWalletAddress;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.createdAtSlot !== "") {
      obj.createdAtSlot = message.createdAtSlot;
    }
    if (message.buys !== undefined) {
      obj.buys = message.buys;
    }
    if (message.sells !== undefined) {
      obj.sells = message.sells;
    }
    if (message.buyVolume !== undefined) {
      obj.buyVolume = message.buyVolume;
    }
    if (message.sellVolume !== undefined) {
      obj.sellVolume = message.sellVolume;
    }
    if (message.volumeUSD !== undefined) {
      obj.volumeUSD = message.volumeUSD;
    }
    if (message.liquidityUSD !== undefined) {
      obj.liquidityUSD = message.liquidityUSD;
    }
    if (message.mcapUSD !== undefined) {
      obj.mcapUSD = message.mcapUSD;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RaydiumSnap>, I>>(base?: I): RaydiumSnap {
    return RaydiumSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RaydiumSnap>, I>>(object: I): RaydiumSnap {
    const message = createBaseRaydiumSnap();
    message.baseMint = object.baseMint ?? "";
    message.quoteMint = object.quoteMint ?? "";
    message.lpMint = object.lpMint ?? "";
    message.market = object.market ?? "";
    message.isSolQuote = object.isSolQuote ?? "";
    message.baseReserve = object.baseReserve ?? "";
    message.quoteReserve = object.quoteReserve ?? "";
    message.initialBaseReserve = object.initialBaseReserve ?? "";
    message.initialQuoteReserve = object.initialQuoteReserve ?? "";
    message.devWalletAddress = object.devWalletAddress ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.createdAtSlot = object.createdAtSlot ?? "";
    message.buys = object.buys ?? undefined;
    message.sells = object.sells ?? undefined;
    message.buyVolume = object.buyVolume ?? undefined;
    message.sellVolume = object.sellVolume ?? undefined;
    message.volumeUSD = object.volumeUSD ?? undefined;
    message.liquidityUSD = object.liquidityUSD ?? undefined;
    message.mcapUSD = object.mcapUSD ?? undefined;
    message.address = object.address ?? undefined;
    return message;
  },
};

function createBasePoolStatSnap(): PoolStatSnap {
  return {
    baseReserve: "",
    quoteReserve: "",
    buys: undefined,
    sells: undefined,
    buyVolume: undefined,
    sellVolume: undefined,
    address: undefined,
    timestamp: undefined,
  };
}

export const PoolStatSnap: MessageFns<PoolStatSnap> = {
  encode(message: PoolStatSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseReserve !== "") {
      writer.uint32(10).string(message.baseReserve);
    }
    if (message.quoteReserve !== "") {
      writer.uint32(18).string(message.quoteReserve);
    }
    if (message.buys !== undefined) {
      writer.uint32(26).string(message.buys);
    }
    if (message.sells !== undefined) {
      writer.uint32(34).string(message.sells);
    }
    if (message.buyVolume !== undefined) {
      writer.uint32(42).string(message.buyVolume);
    }
    if (message.sellVolume !== undefined) {
      writer.uint32(50).string(message.sellVolume);
    }
    if (message.address !== undefined) {
      writer.uint32(58).string(message.address);
    }
    if (message.timestamp !== undefined) {
      writer.uint32(66).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PoolStatSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoolStatSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseReserve = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quoteReserve = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buys = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sells = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buyVolume = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sellVolume = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PoolStatSnap {
    return {
      baseReserve: isSet(object.baseReserve) ? globalThis.String(object.baseReserve) : "",
      quoteReserve: isSet(object.quoteReserve) ? globalThis.String(object.quoteReserve) : "",
      buys: isSet(object.buys) ? globalThis.String(object.buys) : undefined,
      sells: isSet(object.sells) ? globalThis.String(object.sells) : undefined,
      buyVolume: isSet(object.buyVolume) ? globalThis.String(object.buyVolume) : undefined,
      sellVolume: isSet(object.sellVolume) ? globalThis.String(object.sellVolume) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : undefined,
    };
  },

  toJSON(message: PoolStatSnap): unknown {
    const obj: any = {};
    if (message.baseReserve !== "") {
      obj.baseReserve = message.baseReserve;
    }
    if (message.quoteReserve !== "") {
      obj.quoteReserve = message.quoteReserve;
    }
    if (message.buys !== undefined) {
      obj.buys = message.buys;
    }
    if (message.sells !== undefined) {
      obj.sells = message.sells;
    }
    if (message.buyVolume !== undefined) {
      obj.buyVolume = message.buyVolume;
    }
    if (message.sellVolume !== undefined) {
      obj.sellVolume = message.sellVolume;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PoolStatSnap>, I>>(base?: I): PoolStatSnap {
    return PoolStatSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PoolStatSnap>, I>>(object: I): PoolStatSnap {
    const message = createBasePoolStatSnap();
    message.baseReserve = object.baseReserve ?? "";
    message.quoteReserve = object.quoteReserve ?? "";
    message.buys = object.buys ?? undefined;
    message.sells = object.sells ?? undefined;
    message.buyVolume = object.buyVolume ?? undefined;
    message.sellVolume = object.sellVolume ?? undefined;
    message.address = object.address ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBasePumpfunDevStatSnap(): PumpfunDevStatSnap {
  return { created: "", migrated: "", address: undefined };
}

export const PumpfunDevStatSnap: MessageFns<PumpfunDevStatSnap> = {
  encode(message: PumpfunDevStatSnap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.created !== "") {
      writer.uint32(10).string(message.created);
    }
    if (message.migrated !== "") {
      writer.uint32(18).string(message.migrated);
    }
    if (message.address !== undefined) {
      writer.uint32(26).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PumpfunDevStatSnap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePumpfunDevStatSnap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.created = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.migrated = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PumpfunDevStatSnap {
    return {
      created: isSet(object.created) ? globalThis.String(object.created) : "",
      migrated: isSet(object.migrated) ? globalThis.String(object.migrated) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
    };
  },

  toJSON(message: PumpfunDevStatSnap): unknown {
    const obj: any = {};
    if (message.created !== "") {
      obj.created = message.created;
    }
    if (message.migrated !== "") {
      obj.migrated = message.migrated;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PumpfunDevStatSnap>, I>>(base?: I): PumpfunDevStatSnap {
    return PumpfunDevStatSnap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PumpfunDevStatSnap>, I>>(object: I): PumpfunDevStatSnap {
    const message = createBasePumpfunDevStatSnap();
    message.created = object.created ?? "";
    message.migrated = object.migrated ?? "";
    message.address = object.address ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
